# 코드에서 나는 악취
[기이한 이름](#id-section1)<br>
[중복 코드](#id-section2)<br>
[긴 함수](#id-section3)<br>
[긴 매개변수 목록](#id-section4)<br>
[전역 데이터](#id-section5)<br>
[가변 데이터](#id-section6)<br>
[뒤엉킨 변경](#id-section7)<br>
[산탄총 수술](#id-section8)<br>
[기능 편애](#id-section9)<br>
[데이터 뭉치](#id-section10)<br>
[기본형 집착](#id-section11)<br>
[반복되는 switch문](#id-section12)<br>
[반복문](#id-section13)<br>
[성의 없는 요소](#id-section14)<br>
[추측성 일반화](#id-section15)<br>
[임시 필드](#id-section16)<br>
[메세지체인](#id-section17)<br>
[중재자](#id-section18)<br>
[내부자 거래](#id-section19)<br>
[거대한 클래스](#id-section20)<br>
[서로 다른 인터페이스의 대안 클래스들](#id-section21)<br>
[데이터 클래스](#id-section22)<br>
[주석](#id-section24)<br>


<div id='id-section1'/>

## 3.1 기이한 이름 Mysterious Name
> 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 '이름'
<br>함수, 모듈, 변수, 클래스 등은 그 이름만 보고 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경 써서 이름을 지어야 한다.

<br>
<div id='id-section2'/>


## 3.2 중복 코드 Duplicated Code

### 중복 코드의 예
- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우
	 
	 - [x] 함수 추출하기

 * 코드가 비슷하긴 한데 완전히 똑같지 않다면
	 - [x] 문장 슬라이드하기로 비슷한 부분을 한곳에 모아 
	 - [x] 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴보기

 * 같은 부모로부터 파생된 서브 클래스들에 코드가 중복
	 - [x] 메서드 올리기 적용해 부모로 옮긴다.


<br>
<div id='id-section3'/>

## 3.3 긴 함수 Long Function
> 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것.

### :black_nib: 짧은 함수 
##### :pushpin:&nbsp;&nbsp;좋은 이름

    * 함수를 쪼개야 한다.
    * 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
    * 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고
    * 함수 이름은 동작 방식이 아닌 '의도(intension)' 드러나게 짓는다.
    * 원래 코드보다 길어지더라도 함수로 뽑는다.
    * 단, 함수 이름에 코드의 목적을 드러내야 한다. 
    * 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가.
    * 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리.
##### :pushpin:&nbsp;&nbsp;함수 추출하기
>함수 본문에서 따로 묶어 배내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것.

##### ⚠️&nbsp;&nbsp;~~매개변수와 임시 변수를 많이 사용~~한다면 **추출 작업에 방해**가 된다. 
    🙆‍♀️ 임시 변수를 ➰ 질의 함수로
    🙆‍♀️ 매개변수의 수 ➰ 매개변수 객체 만들기, 객체 통쟤로 넘기기로 줄임.
    🙆‍♀️ 이렇게 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 ➰ 함수를 명령으로 바꾸기
##### :mag_right:&nbsp;&nbsp;&nbsp;추출할 코드 덩어리 찾는 방법

    💡 주석을 참고
      - 주석이 설명하는 코드와 함계 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다.
      - 코드가 단 한줄이라도 따로 설명할 필요가 있다면 함수로 추출하는게 좋다.
    
    💡 조건문 반복문 
      - 조건문 분해하기로 대응
      - 거대한 switch문을 구성하는 case문마다 함수 추출하기를 적용, 각 case의 본문을 함수 호출문 하나로 바꾼다.
      - 같은 조건을 기준으로 나뉘는 switch문이 여러 개
        -> 조건문을 다형성으로 바꾸기 적용
	  - 반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다.
	  - 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 다른 두 가지 작업이 섞여 있기 때문 
	    -> 과감히 반복문 쪼개기를 적용해서 작업을 분리

<br>
<div id='id-section4'/>

## 3.4 긴 매개변수 목록 Long Parameter List

> 함수에 필요한 것들을 모조기 매개변수로 전달 
> -> 전역 데이터가 늘어나는 사태를 막을 수 있기 때문에 예전에는 합리적인 방식.<br>
> 하지만 **매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많았다.** 

### :cyclone: 긴 매개변수 처리

  -  다른 매개변수에서 값을 얻어올 수 있는 매개변수 
	  - [x] 매개변수를 질의 함수로 바꾸기
<br>

  - 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드
	  - [x] 객체 통쨰로 넘기기 적용해서 원본 데이터 구조를 그대로 전달
<br>

   - 항상 함께 전달되는 매개변수
	  - [x] 매개변수 객체 만들기로 하나로 묶기
<br>

   - 함수 동작 방식을 정하는 플래그 역할의 매개변수
	  - [x] 플래그 인수 제거하기로 없애기
<br>

  - 항상 함께 전달되는 매개변수
	  - [x] 매개변수 객체 만들기로 하나로 묶기
<br>

 - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 
 	  - [x] 여러 함수를 클래스로 묶기를 이용하여 공통 값들을 클래스의 필드로 정의

<br>
<div id='id-section5'/>

## 3.5 전역 데이터 Global Data
> 전역 데이터를 주의해야 한다는 말은 개발 초창기부터 들었던 말.
> "우리가 겪을 수 있는 악취 중 가장 지독한 축에 속함"<br>
> "**전역 데이터가 아주 조금만 있더라도 <u>캡슐화하는 것</u>이  <br>
> 소프트웨어가 진화하는 데 따른 변화에 대처할 수 있다.**"

#### ⚠️ &nbsp;&nbsp;전역 변수의 문제점
	😨 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는게 문제.
	😨 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

#### 💊 &nbsp;&nbsp;전역 변수 방지

    🙆‍♀️ 변수 캡슐화
    * 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 적용
    * 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
    * 접근자 함수들을 클래스나 모듈에 접어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.

#### ⚠️ &nbsp;&nbsp;전역 데이터가 가변 mutable

    * 다루기 까다롭다.
    * 프로그램이 구동된 후에는 값이 바뀌지 않는다고 보장할 수 있는 전역 데이터는 그나마 안전한 편이다.

<br>
<div id='id-section6'/>

## 3.6 가변 데이터 Mutable Data
	* 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 
	프로그램이 오작동한다. 
	* 이 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기가 매우 어렵다.
	* 데이터는 절대 변하지 않고, 
	  데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 
	  해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

#### 💊 &nbsp;&nbsp;무분별한 데이터 수정에 따른 위험을 줄이는 방법

   - [x] 변수 캡슐화하기
```
* 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 캡슐화하면 
-> 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다. 
```
	
   - [x] 변수 쪼개기
```
* 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우
-> 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.	
```
   - [x] 문장 슬라이드하기 와 함수 추출하기
```
-> 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리
```
   - [x] 질의 함수와 변경 함수 분리하기
```
* API 를 만들 때	
```
   - [x] 세터 제거하기
```
-> 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움	
```
   - [x] 여러 함수를 클래스로 묶기나 여러 함수를 변수로 묶기
```
-> 변수를 갱신하는 코드들의 유효범위를 (클래스나 변환transform) 제한한다.	
```
   - [x] 참조를 값으로 바꾸기
```
* 구조체처럼 내부 필드에 데이터를 담고 있는 변수일 때
-> 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.	
```

<br>
<div id='id-section7'/>

## 3.7 뒤엉킨 변경 Divergent Change
> 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다. <br>
> 이렇게 할 수 없다면 (서로 밀접한 악취인) **뒤엉킨 변경과 산탄총 수술중 하나가** 풍긴다.

#### ⚠️&nbsp;&nbsp;뒤엉킨 변경

    * 단일 책임 원칙(Single Responsiblity Principle)이 제대로 지켜지지 않을 때 나타남.
    * 즉 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

#### 🙆‍♀️&nbsp;&nbsp;단일 원칙 지키기 예

    * 단계 쪼개기
     - 데이터베이스에서 데이터를 가져와서 금융 상품 로직에서 처리해야 하는 일처럼 순차적으로 실행되는 게 자연스러운 맥락일 때
     - 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리
    
    * 함수 옮기기
      - 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면
      - 각 맥락에 해당하는 적당한 모듈을 만들어서 관련 함수를 모은다.
      - 그러면 처리 과정이 맥락별로 구분된다.
      - 이 때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 (함수 추출하기)부터 수행한다. 
      - 모듈이 클래스라면 (클래스 추출하기)가 맥락별 분리 방법을 잘 안내해 준다.

<br>
<div id='id-section8'/>

## 3.8 산탄총 수술 Shotgun Surgery

> 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.

<table>
  <tr>
    <th></th>
    <th>뒤엉킨변경</th>
    <th>산탄총 수술</th>
  </tr>
  <tr>
    <td>원인</td>
    <td colspan="2" align=center>맥락을 잘 구분하지 못함</td>
  </tr>
  <tr>
    <td>해법(원리)</td>
    <td colspan="2" align=center>맥락을 명확히 구분</td>
  </tr>
  <tr>
    <td>발생 과정(현상)</td>
    <td>한 코드에 섞여 들어감</td>
    <td>여러 코드에 흩뿌려짐</td>
  </tr>
  <tr>
    <td>해법(실제 행동)</td>
    <td>맥락별로 분리</td>
    <td>맥락별로 모음</td>
  </tr>
</table>

    * 이럴 때는 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어두면 좋다.
    * 비슷한 데이터를 다루는 함수가 많다면 -> 여러 함수를 클래스로 묶기 적용
    * 데이터 구조를 변환하거나 보강하는 함수들에는 -> 여러 함수를 변환 함수로 묶기
    * 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 -> 단계 쪼개기 적용
    * 어설프게 분리된 로직을 -> 함수 인라인하기나 클래스 인라인하기 -> 하나로 합치는 것도 좋은 방법
    * 메서드나 글래스가 비대해지지만, 나중에 추출하기 리팩터링으로 더 좋은 형태로 분리할 수 있다.

<br>
<div id='id-section9'/>

## 3.9 기능 편애 Feature Envy
 

> 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다<br>
> 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새

 #### 🔗&nbsp;&nbsp;프로그램 모듈화
 

    코드를 여러 영역으로 나눈 뒤
    영역 안에서 이뤄지는 상호작용은 최대한 늘리고 
    영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력.

 #### 👀&nbsp;&nbsp;기능 편애
 

 - 실행 과정에서 외부 객체의 게터 메서드 대여섯 개를 호출하도록 작성된 함수 <br>
	 - [x] 데이터 근처로 옮기기(함수 옮기기)<br>
 
 - 함수의 일부에서만 기능을 편애 <br>
	 - [x] 그부분만 독립 함수로 빼낸 다음 (함수 호출하기) 
	 - [x] 원하는 모듈로 보내준다 (함수 옮기기)

 - 어디로 옮길지 명확하게 드러나지 않을 때, 함수가 사용하는 모듈이 다양할 때 <br>
	 - [x] 가장 많은 데이터를 포함한 모듈로 옮긴다.
	 - [x] 함수 추출하기로 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮기면 더 쉽게 해결
 
<br>
<div id='id-section10'/>

## 3.10 데이터 뭉치 Data Clumps
> 데이터 항목들은 서로 어울려 노는 걸 좋아한다.<br>
> 이렇게 몰려다니는 데이터 뭉치는 **보금자리를 따로 마련해줘야 마땅**하다.

 #### 💼&nbsp;&nbsp;데이터 보금자리 만들기

 - 필드 형태의 데이터 뭉치를 찾아서 
	 - [x] **클래스 추출**하기로 하나의 객체로 묶기
 - 다음은 메서드 시그니처에 있는 데이터 뭉치 차례

 	 - [x] **매개변수 객체 만들기**나 **객체 통째로 넘기기**를   적용해서 매개변수 수를 줄여본다.
 	 - [x] 👍 메서드 호출이 간결해질 것.

 -  클래스를 이용하면 좋은 향기를 흩뿌릴 기회가 생긴다.
 -  클래스를 옮기면 좋을 동작은 없는지 살펴본다.

 <br>
 
 #### ❓&nbsp;&nbsp;데이터 뭉치 판별
 
 - 값 하나를 삭제 
 - 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치.
<br>
<div id='id-section11'/>

## 3.11 기본형 집착 Primitive Obsession

 - **기본형을 객체로 바꾸기**
 - 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면
	- [x] **타입 코드를 서브클래스로 바꾸기** 
	- [x] **조건부 로직을 다형으로 바꾸기**를 차례로 적용

 - 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치<br>
	- [x] **클래스 추출하기**와 **매개변수 객체 만들기**를 이용

<br>
<div id='id-section12'/>

## 3.12 반복되는 switch문 Repeated Switches

> 코드에 등장하는 switch문은 모조리<br>
> **💫 조건부 로직을 다형성으로 바꾸기**로 없애야 할 대상이라고 주장한다.

 - 똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드에 집중.
 - 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문.

<br>
<div id='id-section13'/>

## 3.13 반복문 Loops

> 반복문을 파이프라인으로 바꾸기를 적용해서 반복문을 제거할 수 있게 됐다.
> 필터filter나 맵map 같은 파이프라인 연산을 사용

<br>
<div id='id-section14'/>

## 3.14 성의 없는 요소 Lazy Element

- 구조가 필요 없을 때
- 본문 코드를 그대로 쓰는 것과 진배없는 함수
- 메서드가 하나 뿐인 클래스
	- [x] **함수 인라인**, **클래스 인라인**으로 처리

- 클래스 인라인으로 상속을 사용했다면 
	- [x] **계층 합치기**를 적용

<br>
<div id='id-section15'/>

## 3.15 추측성 일반화 Speculative Generality

> 이 냄새는 ~~'나중에 필요할 거야' 라는 생각~~으로 **당장은 필요 없는 모든 종류의 후킹**<br>
> 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다.

- 하는 일이 거의 없는 추상 클래스
	- [x] **계층 합치기** 

- 쓸데없이 위임하는 코드
	- [x] **함수 인라인**하기나 **클래스 인라인**하기로 삭제.

- 본문에서 사용되지 않는 매개변수
	- [x] **함수 선언 바꾸기**로 없앤다.

<br>
<div id='id-section16'/>

## 3.16 임시 필드 Temporary Field

- 덩그러니 떨어져 있는 필드들을 발견 
	- [x] 💫 **클래스 추출하기**로 제 살 곳을 찾아준다.
	- [x] 그런 다음 **함수 옮기기**로 **임시 필드들과 관련된 코드를<br>모조리 새 클래스에 몰아 넣는**다.


- 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직이 있을 수 있는데 <br>
	- [x] **특이 케이스 추가하기**로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거



<br>
<div id='id-section17'/>

## 3.17 메세지 체인 Message Chains

> 한 객체(A)를 통해 다른 객체(B)를 얻은 뒤 B 객체에 또 다른 객체(C)를 요청하는 식<br>
> 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드.

#### 💊&nbsp;&nbsp;위임 숨기기

    1. 최종 결과 객체가 어떻게 쓰이는지 살펴본다.
    
    2. 함수 추출하기
      : 결과 객체를 사용하는 코드 일부를 따로 빼냄
    
    3. 함수 옮기기
	  : 체인을 숨길 수 있는지 살펴본다.  
	 
	managerName = aPerson.department.manager.name;
	-> 💊 위임 숨기기
	managerName = aPerson.department.managerName // 관리자 객체(manager) 숨김
	managerName = aPerson.manager.name // 부서 객체(department)의 존재를 숨김
	managerName = aPerson.managerName // 부서 객체와 관리자 객체 모두의 존재를 숨김
	
	이 체인의 최종 결과 객체는 name이 반환하는 부서장의 이름이다. 
	
			managerName = aPerson.department.manager.name;
			
			report = '${managerName}께
			${aPerson.name} 님의 작업 로그
			...'
			
			console.log(report)
	
	여기서 보고서 생성 로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감춰짐.
	console.log(reportAutoGenerator.report(aPerson));			
 			 
<br>
<div id='id-section18'/>

## 3.18 중재자 Middle man

> 클래스가 제공하는 메서드 중 절반에 다른 클래스에 구현을 위임하고 있을 때 <br>
> **중개자 제거하기**를 활용 <br>
> 실제로 일을 하는 객체와 직접 소통하게 하자.

<br>
<div id='id-section19'/>

## 3.19 내부자 거래 Insider Trading

> 일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만<br>
> 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

- 은밀히 데이터를 주고받는 모듈들이 있을 때 
	- [x] **함수 옮기기**와 **필드 옮기기**로 떼어놓아서 
	- [x] 사적으로 처리하는 부분을 줄인다.

- 여러 모듈이 같은 관심사를 공유 
	 - [x] 공통 부분을 정식으로 처리하는 **제3의 모듈을 새로 만들거**나
	 - [x] **위임 숨기기**를 이용하여 **다른 모듈이 중간자 역할**을 하게 만든다.

- 상속 구조에서 자식 클래스가 부모 품을 떠나야 할 때 
	- [x] **서브클래스를 위임으로 바꾸기** 
	- [x] **슈퍼클래스를 위임으로 바꾸기**를 활용

<br>
<div id='id-section20'/>

## 3.20 거대한 클래스 Large Class

#### ⚠️&nbsp;&nbsp;문제점
	너무 많은 일을 하려다 보면 필드 수가 상당히 늘어남.
	클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

### 거대한 클래스 리팩토링 

#### **💊&nbsp;&nbsp;클래스 추출하기** 
- [x] 필드를 일부를 따로 묶는다.
- [x] 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택.
- [x] 한 클래스 안에서 접두어나 접미어가 같은 필드들이 함께 추출할 후보.
- 분리한 컴포넌트를 원래 클래스와 상속 관계가 좋다면 (클래스 추출하기보다는)
	- [x] 슈퍼클래스 추출하기나 (실질적으로 서브클래스 추출하기에 해당하는) 
	- [x] 타입 코드를 서브클래스로 바꾸기로 적용하는 편이 더 쉽다.

#### **💊&nbsp;&nbsp;중복 제거** 
- 상당량의 로직이 똑같은 메서드 다섯 개가 있다면 
	- [x] 각각의 💫 **공통 부분을 작은 메서드**들로 뽑아내자.

#### **💊&nbsp;&nbsp;거대 클래스 이용 패턴을 파악** 
- [x] 클라이언트들이 거대 클래스의 특정 기능 그룹만 주로 사용하는지 살핀다.
- [x] 이때 🔌 **각각의 기능 그룹** 이 💫 **개별 클래스로 추출**될 후보.
	- 유효한 기능 그룹을 찾았다면 아래의 것을 활용하여 여러 클래스로 분리
		 - [x] 클래스 추출하기
		 - [x] 슈퍼클래스 추출하기
		 - [x] 타입 코드를 서브클래스로 바꾸기 

<br>
<div id='id-section21'/>

## 3.21 서로 다른 인터페이스의 대안 클래스들
- **함수 선언 바꾸기**로 메서드 시그니처를 일치시킨다
- 부족할 때는 **함수 옮기기**를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
- 대안 클래스들 사이에 중복 코드가 생기면 **슈퍼클래스 추출**하기 적용 고려

<br>
<div id='id-section22'/>

## 3.22 데이터 클래스 Data Class
- 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다.

- public 필드가 있다면
	- [x] **레코드 캡슐화하기**

- 다른 클래스 메서드 -> 데이터 클래스의 게터나 세터를 사용할 때 
	 - [x] 함수 옮기기로 **데이터 클래스로 옮길 수 있는지**
	 - [x] 메서드를 통째로 옮기기 어렵다면 **함수 추출하기를 이용해서 부분만 별도 메서드**로 뽑아내기 

- 불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로부터 나오는 정보는 필드 자체를 공개해도 된다. 

<br>
<div id='id-section24'/>

## 3.24 주석 Comments

> 주석은 악취가 아닌 향기를 입힌다.<br>
> 문제는 주석을 탈취제처럼 사용하는 데 있다. <br>
> 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.<br>
> "주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩토링해본다."

- 주석을 남기고 싶다면 
	 - [x] 함수 추출하기를 적용

- 추출이 되어있는 함수임에도 여전히 설명이 필요하다면
	 - [x] 함수 선언 바꾸기로 이름을 바꿔본다.

- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면
	 - [x] 어서션 추가하기


<!--stackedit_data:
eyJoaXN0b3J5IjpbNDIyNTAwODE1LC0xNDA4NDM2MDksMTU0Mz
M3NjA5NiwxOTQ3MzgyOTQ0LDU1NDMxNDM2LDEyMzQyMDM5Miwx
NTE5MTU0NzE3LC01Mzc5MzkzODUsMjkwMDc3NzgxLDQzODM2OT
QyOSwtMTY3ODU0NTQyNyw5NDg4MDMyNjksNDA1MDM2NDcyLC0x
MDk4NDgyNzE2LDU3NDA2ODE0NywyMDc2ODY1ODQzLDc5NzA3NT
csLTE4OTA5MzAzNDUsLTE4NDkzNTU5OTEsLTQzNTU1ODg5NV19

-->