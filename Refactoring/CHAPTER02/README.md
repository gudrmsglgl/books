# 리팩터링 원칙
[리택터링 정의](#id-section1)<br>
[두 개의 모자](#id-section2)<br>
[리팩터링하는 이유](#id-section3)<br>
[언제 리팩터링해야 할까](#id-section4)<br>
[리팩터링 시 고려할 문제](#id-section5)<br>
[리팩터링, 아키텍처, 애그니(YAGNI)](#id-section6)<br>
[리팩터링과 소프트웨어 개발 프로세스](#id-section7)<br>
[리팩터링과 성능](#id-section8)
<br><br>
<div id='id-section1'/>

## 2.1 리팩터링 정의 
> **리택터링**: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 <u>**이해하고 수정하기 쉽도록**</u> <br> 내부 구조를 변경하는 기법

> **리택터링**: [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, <u>**여러 가지 리팩터링 기법을 적용**</u>해서 <br>소프트웨어를 재구성하다.

### **리택터링**
    * 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고 단계들을 순차적으로 연결하여 큰 변화를 만들어 내는 일.
    * 리택터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않더라도 언제든 멈출 수 있다.
    * 잘게 나눔으로써 작업을 더 빨리 처리할 수 있고, 디버깅 시간 축소 
    * 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것
<br>
<div id='id-section2'/>

## 2.2 두 개의 모자
### :guardsman: 기능 추가, 리택터링
:on: 기능추가

    기존 코드는 건드리지 않고 새 기능을 추가하기만 한다.

:on: 리택터링

    기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.

> _Tip_. 개발 시 기능추가를 하고 코드를 보며 구조 개선이 필요하다고 생각되면 모자를 바꿔 리택터링 후<br> 코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 기능 추가를 이어간다.  

<br>
<div id='id-section3'/>

## 2.3 리팩터링하는 이유
### :one: **&nbsp;리팩터링하면 소프트웨어 설계가 좋아진다**
    중복 코드 제거
    * 설계 개선 작업의 중요한 한 축을 차지    
    * 모든 코드가 언제나 고유한 일을 수행함을 보장
### :two: **&nbsp;리팩터링하면 소프트웨어를 이해하기 쉬워진다**
    코드의 목적이 더 잘 드러나게, 의도를 명확하게 전달하도록 개선할 수 있다.

### :three: **&nbsp;리택터링하면 버그를 쉽게 찾을 수 있다**
### :four: **&nbsp;리팩터링하면 프로그래밍 속도를 높일 수 있다**
    * 리팩터링하면 코드 개발 속도를 높일 수 있다.
    * 코드가 명확하면 버그를 만들 가능성도 줄고 버그를 만들더라도 디버깅하기 훨씬 쉽다.
    * 지구력 가설
      :내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다

<br>

<div id='id-section4'/>

## 2.4 언제 리팩터링해야 할까? 
> **3의 법칙**
<br>1. 그냥한다
<br>2. 비슷한 일을 두 번째로 하게 되면 일단 진행한다
<br>3. 비슷한 일을 세 번째 하게 되면 리팩터링한
### **준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
    ex) 함수 매개변수화하기
### **이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
> Ralph johnson: 초기 단계의 리팩터링을 밖을 잘 내다보기 위한 창문 닦기 

    * 조건부 로직 구조 이상하지 않은지
    * 함수 이름을 잘못 정해서 파악하는 데 오래 걸리지는 않는지
    * 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고
    * 긴 함수를 잘게 나누기

### **쓰레기 줍기 리팩터링**

> 간단히 수정할 수 있는 것은 즉시 고치고, 
> 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 처리 

    * 로직이 쓸데없이 복잡
    * 거의 똑같은 함수 여러 개로 작성 -> 매개변수화한 함수


### **계획된 리팩터링과 수시로 하는 리팩터링**

> 보기 싫은 코드 -> 리팩토링
> But! 잘 작성된 코드 -> 수많은 리팩터링

> " 무언가를 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고
> 그런 다음 쉽게 수정하자 " _켄트 백

> 뛰어난 개발자는  
> 새 기능을 추가하기 쉽도록 코드를 '수정' 하는 것이  
> 그 기능을 가장 빠르게 추가하는 길일 수 있음 안다.

### **오래 걸리는 리팩터링**
> 주어진 문제를 몇 주에 걸쳐 조금씩 해결하는 편이 효과적 

### **코드 리뷰에 리팩터링 활용하기**
> 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링 하는 것
> -> pair programming

### **리팩터링하지 말아야 할 때**
    * 지저분한 코드를 발견해도 굳이 수정할 필요가 없을 때
    * 외부 API 다루듯 호출해서 쓰는 코드
    * 처음부터 새로 작성하는 게 쉬울 때 
<br>
<div id='id-section5'/>

## 2.5 리팩터링 시 고려할 문제
### :shipit: **새 기능 개발 속도 저하**
> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출한는 것이다.

>건강한 코드의 위력을 충분히 경험해보지 않고서는<br>
코드베이스가 건강할 때와 허약할 때의 생산성 차이를 체감하기 어렵다.

> 생각의 오류<br>
:no_good:&nbsp;&nbsp;'클린코드' 나  '바람직한 엔지니어링 습관' 처럼 도덕적인 이유로 정당화하는 것.<br>
:no_good:&nbsp;&nbsp;코드 베이스를 예쁘게 꾸미는 데 있지 않다.<br>
:ok_woman:&nbsp;&nbsp;오로지 경제적인 이유, 개발 기간을 단축, 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다. 

### :shipit: **브랜치**

    * 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다.
    * 머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 기하급수적으로 늘어난다.
    

  

##### :ok_woman: &nbsp;**브랜치 관리**

	기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리 혹은 더 짧게 (CI, TBD)
    마스터를 건강하게 유지하고, 
    거대한 기능을 잘게 쪼개는 법을 배우고, 
    각 기능을 끌 수 있는 기능 토글(feature flag)을 적용하여 
    -> 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.

#####  :question: &nbsp;**기능별 브랜치 사용**  

    브랜치를 자주 통합할 수 있다면 문제가 발생할 가능성을 크게 줄일 수 있다.
    CI를 적용하는 이들도 기능별 브랜치를 많이 사용(단, 마스터와 통합하는 작업 매일)
    
### :shipit: **테스팅**

#####  :white_check_mark: &nbsp;자가 테스트 코드

    * 리팩터링 효과적
    * 새 기능 추가도 훨씬 안전하게 진행 → 실수로 만든 버그를 빠르게 제거
    * 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있음
    * 리택터링 과정에서 버그 생길 위험이 크다는 불안감 해소

### :shipit: **레거시 코드**

> 대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.

#####  :no_entry_sign:&nbsp; 테스트코드
    * 테스트 코드 보강
    * 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트
    * 이러한 틈새를 만들 때 리팩터링이 활용된다.
    * 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서라면 감내해야 할 위험.
    
##### :o: &nbsp;테스트코드
	* 서로 관련된 부분끼리 나눠서 하나씩 공략.
	* 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링

<br>
<div id='id-section6'/>

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

> 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다.

:pushpin:&nbsp;&nbsp;**아키텍처 설계 시**

    * 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두는 것.
    * 함수를 정의하다 보면 범용적으로 사용할 수 있겠다는 생각들 때 → 예상 시나리오에 대응하기 위한 매개변수(유연성 메너니즘)추가.
	
	🚷 [유연성 메커니즘의 주의점]
    * 매개변수를 생각나는 대로 추가 → 복잡
    * 요구사항이 당초 예상과 다르게 바뀔 때
    * 내가 설계한 메커니즘 자체 결함 있을 수 있음
	
	👆 [리팩터링 활용 시]
	* 어느 부분에 유연성이 필요하고 변화에 잘 대응할 수 있을지 추측 x
	* 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축
	* 단 이 요구를 멋지게 해결하도록 설계
	* 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꿈

💁&nbsp;&nbsp;**이렇게 해보세요**

    👏 (작고 멋진 이름의 함수) 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가
    🙏 (복잡도를 높일 수 있는 유연성 메커니즘) 반드시 검증을 거친 후에 추가.
    💫 (함수 매개변수화하기) 
       호출하는 측에서 **항상 같은 값을 넘기는 매개변수는** 
       매개변수 목록에 넣지 않고 
       매개변수를 추가해야 할 시점이 오면(함수 매개 변수화하기)로 해결한다
> ###### 이런식으로 설계하는 방식을 간결한 설계(simple design), 점진적 설계(incremental design) , YAGNI("you aren't going to need it") <br>YAGNI는 아키텍처를 고려하지 말라는 뜻이 아니며, 아키텍처와 설계를 개발 프로세스에 녹이는 또 다른 방식이며, 리팩터링의 뒷받침 없이는 효과를 볼 수 없다
<br>
<div id='id-section7'/>

## 2.7 리팩터링과 소프트웨어 개발 프로세스

##### :pushpin:&nbsp;&nbsp;**익스트림 프로그래밍XP (애자일 방법론 중 하나)**
    지속적 통합, 
    자가 테스트 코드, 
    리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스 

### <img src="https://image.flaticon.com/icons/png/512/2784/2784065.png" width="25" height="28"/>  Agile
> 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 
> 리팩터링이 자연스럽게 스며들도록 해야 한다.<br>
> 🔜  견고한 기술적 토대를 갖추면 좋은 아이디어를 프로덕션 코드로 반영하는 시간 단축

    * 리팩토링의 첫 번째 토대는 자가 테스트 코드다. 
    * 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.
    * 팀으로 개발하면서 리팩터링을 하려면 🚧 {각 팀원이 다른 사람의 작업을 방해하지 않으면서}🚧 언제든지 리팩터링할 수 있어야 한다.

    자가 테스트 코드, 지속적 통합, 리팩터링
    * 지속적 통합은 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다. 
    * 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세기법은 서로 강력한 상승효과 발휘.
    * 수 많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기 훨씬 쉽다. 
    * 세 가지 실천법을 잘 조화시키면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 심을 수 있다. 
	
	지속적 배포
	* 소프트웨어를 언제든 릴리스할 수 있는 상태 유지.
	* 위험요소도 줄이고, 비즈니스 요구에 맞춰 릴리스 일정을 계획할 수 있다. 

<br>
<div id='id-section8'/>

## 2.8 리팩터링과 성능

### :mask: 직관적인 설계 vs 성능

> 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것.

### :ear: 빠른 소프트웨어를 작성하는 방법 세 가지

    1.시간 예산 분배 방식
    * 가장 엄격한 방법, 하드 리얼타임 시스템에서 많이 사용
    * 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당.
    * 컴포넌트는 할당된 자원 예산을 초과할 수 없다.
    * 엄격한 시간 엄수를 강조.
    ⭕️ 심장 박동 조율기(늦게 도착하면 안 되는 시스템),🚫 사내 정보 시스템
	
	2.끊임없이 관심을 기울인다.
	3.의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다.

<!--stackedit_data:
eyJoaXN0b3J5IjpbNjc4MTEzNjI1LC0xODQyNjk2OTc1LC00ND
U3ODAwMzIsLTE3NzQzMDk3MTcsLTExNTg3NDI1MywyMDMxOTYx
MzExLDExNDc5NTY0NDksNzAwOTYwNjYsMTY0MDQ1NDIwMSwtMT
ExOTY0ODI3NCwtMTYzODg1MDc5NSwxMzA2NjAxODIzLDE3NjI1
NjYxMjcsLTE5Mzk1MTU0NDMsMzczNzU4ODM0LC04MjY4MDQ2Mz
UsLTgzMzY2ODc1NSwtODMzNjY4NzU1LDQxMjk0OTExLDM1NTAx
ODQxM119
-->