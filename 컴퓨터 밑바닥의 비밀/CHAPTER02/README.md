# 프로그램이 실행되었지만, <br>뭐가 뭔지 하나도 모르겠다

목차 <br>
[Section2.1 운영 체제, 프로세스, 스레드의 근본 이해하기](#id-section1)<br>
- [2.1.1 모든 것은 CPU에서 시작된다](#id-section2)<br>
- [2.1.2 CPU에서 운영 체제까지](#id-section3)<br>



<div id='id-section1'/>

## section1 운영 체제, 프로세스, 스레드의 근본 이해하기

<br>
<div id='id-section2'/>

### 2.1.1 모든 것은 CPU에서 시작된다.

CPU는 사실 스레드, 프로세스, 운영 체제 같은 개념을 ✌🏻전혀✌🏻 알지 못함.

<br>

**🤖 CPU가 알고 있는 단 두 가지**
1. 메모리에서 명령어(instruction)를 하나 가져옵니다(dispatch)
2. 이 명령어를 실행(execute)한 후 다시 1번으로 돌아갑니다.

<br>

**🧐 CPU는 어떤 기준으로 메모리에서 명령어를 가져올까?**
> 프로그램 카운터(program counter: PC) 라고 불리는 레지스터에서 찾을 수 있음<br>
>  - 레지스터: 용량은 매우 작지만 속도는 매우 빠른 일종의 메모리

<br>

**🧐 PC 레지스터에 저장되는 것은 무엇일까?**
> 메모리에 저장된 명령어 **⚡️주소️ ⚡**
>  - 어떤 명령어 주소를 저장? 💁🏻 CPU가 다음에 실행할 명령어
>
![IMG_0402](https://github.com/user-attachments/assets/ec269b37-d91b-4505-9102-98429a9019b5)

PC레지스터가 저장하는 주소는 기본적으로 1씩 자동으로 증가. <br>
대부분 CPU가 주소를 하나씩 증가시키면서 차례대로 명령어를 실행하기 떄문에 <br>
이런 동작 방식은 매우 일리가 있음 <br>
<br>
**하지만 if-else 또는 함수 호출 같은 ✌🏻명령어✌🏻를 만나면 순차적인 실행 순서는 파괴** <br>
이런 명령어를 실행할 때 CPU는 연산 결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 <br>
**💁🏻PC 레지스터 값을 동적으로 변경** <br>
<br>
위와 같은 방식으로 CPU는 실행해야 할 명령어로 정확하게 점프할 수 있음<br>
<br><br>

**🧐 그렇다면 최초의 PC레지스터에 저장되는 값은 어디서 오는걸까?**
> 프로그램 실행 과정을 보면 결국 소스코드에서 비롯되고 이는 곧 main() 함수에 대응하는 첫 번째 기계 명령어를 찾고 <br>
> 이어서 그 메모리 주소를 PC 레지스터에 기록 <br>
> (물론 실제 상황은 훨씬 복잡 -> main 실행 전에 일부 레지스터의 초기화처럼 별도의 초기화 과정이 진행된다는 점 유의) 
> ![IMG_0403](https://github.com/user-attachments/assets/6368c52d-1cd2-4930-b2fc-25dddb84def9)


<br>
<div id='id-section3'/>


### 2.1.2 CPU에서 운영 체제까지

**👨🏻‍💻우리가 직접 CPU가 프로그램을 실행하게 하려면**
> 실행 파일을 수동으로 메모리에 복사한 후 <br>
> main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 <br>
> PC 레지스터에 적재하면 된다는 것을 알고 있습니다. <br>

이렇게 하면 운영체제 없이 우리가 직접 CPU에 프로그램을 실행하도록 할 수 있지만 과정이 매우 복잡🤮 <br>
<br><br>
**🤮운영체제 없이 직접 실행이 복잡한 이유**
- 프로그램 적재할 수 있는 적절한 크기의 메모리 영역을 찾습니다.
- CPU 레지스터를 초기화하고 함수의 진입 포인트(entry point)를 찾아 PC 레지스터를 설정합니다.

<br><br>
**🤮순수하게 수동으로 프로그램 실행하는 단점**
1. 한 번에 하나의 프로그램만 실행할 수 있다.
   - 멀티 태스킹 불가 (다중 코어 최대한 활용 불가) 
2. 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해야 하며, 그렇지 않으면 프로그램이 외부 장치를 전혀 사용할 수 없다.
   - 프로그램이 사운드 카드를 사용한다면 사운드 카드 드라이버를 연결해야 함
   - 네트워크 카드를 사용한다면 네트워크 카드 드라이버 연결 및 네트워크 통신 TCP/IP  스택 소스 코드에도 연결해야 함
3. print 함수는 직접 구현해야 함. 최신 운영 체제는 유용한 라이브러리를 다양하게 제공함.
4. 아름다운 상호 작용 인터페이스(interactive interface)를 원한다면 이 모든 것을 직접 구현해야 함

위는 사실 1950~60 년대 프로그램 작성방식. <br>

<br><br>
**🧐프로그램 실행 시 실행 파일을 메모리에 수동으로 복사를 프로그램이 대신 수행하도록 한다면?** <br>
<br>실습 <br>
적재 도구(loader)라는 이름의 프로그램을 하나 작성했고, 적재 도구를 실행하면 프로그램이 메모리에 적재됩니다. <br>
그렇다면 프로그램이 실행된 이후는 여전히 하나의 프로그램만 실행할 수 있을까? <br>
CPU가 하나뿐인 단일 코어 컴퓨터에서 웹 서핑과 코드 작성을 **✌🏻동시✌🏻**에 하고 싶다면 어떻게 해야 할까요? <br>
CPU는 한 번에 한 가지 일만 할 수 있습니다.
> CPU는 먼저 프로그램 A를 실해했다가 이를 잠시 📌중지📌하고 프로그램 B의 실행으로 넘어갑니다. <br>
> 그리고 반대로 B를 실행했다가 이를 잠시 📌중지📌하고 다시 A의 실행으로 돌아갈 수 있습니다. <br>
> **💁🏻 즉, CPU의 전환 빈도가 충분히 빠르다면 A와 B가 '동시에 실행'되는 것처럼 보입니다.**


<br><br>
**🧐포인트는 중지와 실행인데 > 어떻게 하면 프로그램을 일시 중지했다가 다시 시작하느냐가 관건** <br>
<br>농구 경기에서 일시 중지했다가 다시 재개할 떄 처럼 <br>
**일시 중지되었을 때 상태가 유지되고, 그 유지되었던 상태를 이용하여 다시 경기를 재개** <br>
**📌 이때 저장되는 상태를 상황 정보(context)라고 합니다.**

```c
struct ***
{
  context ctx; // CPU의 상황 정보 저장
  ...
}
```

> **우리는 위 구조체에 프로세스(process)라는 이름을 붙입니다.** <br>
> 이제 모든 프로그램은 실행된 후 **✌🏻프로세스 형태로 관리✌🏻** 됩니다. <br>
> 프로세스를 사용하면 모든 프로세스를 원하는 대로 일시 중지하거나 다시 시작할 수 있습니다. => 멀티태스킹 기능 구현 가능해짐

<br>
위 과정을 쭈욱 보면 프로그램을 실행할 떄마다 자동으로 적재해주는 프로그램과 <br>
프로그램을 멀티 태스킹이 가능하게 프로세스로 관리 도구처럼 멋진 기능들을 사용하기 위해 <br>
전체적으로 종합적으로 모아 둔 프로그램 => 운영체제(operating system)
