# 프로그램이 실행되었지만, <br>뭐가 뭔지 하나도 모르겠다

목차 <br>
[Section2.1 운영 체제, 프로세스, 스레드의 근본 이해하기](#id-section1)<br>
- [2.1.1 모든 것은 CPU에서 시작된다](#id-section2)<br>
- [2.1.2 CPU에서 운영 체제까지](#id-section3)<br>
- [2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다](#id-section4)<br>
- [2.1.4 프로세스에서 스레드로 진화](#id-section5)<br>
- [2.1.5 다중 스레드와 메모리 구조](#id-section6)<br>
- [2.1.6 스레드 활용 예](#id-section6)<br>
- [2.1.7 스레드 풀의 동작 방식](#id-section7)<br>
- [2.1.8 스레드 풀의 스레드 수](#id-section8)<br>



<div id='id-section1'/>

## section1 운영 체제, 프로세스, 스레드의 근본 이해하기

<br>
<div id='id-section2'/>

### 2.1.1 모든 것은 CPU에서 시작된다.

CPU는 사실 스레드, 프로세스, 운영 체제 같은 개념을 ✌🏻전혀✌🏻 알지 못함.

<br>

**🤖 CPU가 알고 있는 단 두 가지**
1. 메모리에서 명령어(instruction)를 하나 가져옵니다(dispatch)
2. 이 명령어를 실행(execute)한 후 다시 1번으로 돌아갑니다.

<br>

**🧐 CPU는 어떤 기준으로 메모리에서 명령어를 가져올까?**
> 프로그램 카운터(program counter: PC) 라고 불리는 레지스터에서 찾을 수 있음<br>
>  - 레지스터: 용량은 매우 작지만 속도는 매우 빠른 일종의 메모리

<br>

**🧐 PC 레지스터에 저장되는 것은 무엇일까?**
> 메모리에 저장된 명령어 **⚡️주소️ ⚡**
>  - 어떤 명령어 주소를 저장? 💁🏻 CPU가 다음에 실행할 명령어
>
![IMG_0402](https://github.com/user-attachments/assets/ec269b37-d91b-4505-9102-98429a9019b5)

PC레지스터가 저장하는 주소는 기본적으로 1씩 자동으로 증가. <br>
대부분 CPU가 주소를 하나씩 증가시키면서 차례대로 명령어를 실행하기 떄문에 <br>
이런 동작 방식은 매우 일리가 있음 <br>
<br>
**하지만 if-else 또는 함수 호출 같은 ✌🏻명령어✌🏻를 만나면 순차적인 실행 순서는 파괴** <br>
이런 명령어를 실행할 때 CPU는 연산 결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 <br>
**💁🏻PC 레지스터 값을 동적으로 변경** <br>
<br>
위와 같은 방식으로 CPU는 실행해야 할 명령어로 정확하게 점프할 수 있음<br>
<br><br>

**🧐 그렇다면 최초의 PC레지스터에 저장되는 값은 어디서 오는걸까?**
> 프로그램 실행 과정을 보면 결국 소스코드에서 비롯되고 이는 곧 main() 함수에 대응하는 첫 번째 기계 명령어를 찾고 <br>
> 이어서 그 메모리 주소를 PC 레지스터에 기록 <br>
> (물론 실제 상황은 훨씬 복잡 -> main 실행 전에 일부 레지스터의 초기화처럼 별도의 초기화 과정이 진행된다는 점 유의) 
> ![IMG_0403](https://github.com/user-attachments/assets/6368c52d-1cd2-4930-b2fc-25dddb84def9)


<br>
<div id='id-section3'/>


### 2.1.2 CPU에서 운영 체제까지

**👨🏻‍💻우리가 직접 CPU가 프로그램을 실행하게 하려면**
> 실행 파일을 수동으로 메모리에 복사한 후 <br>
> main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 <br>
> PC 레지스터에 적재하면 된다는 것을 알고 있습니다. <br>

이렇게 하면 운영체제 없이 우리가 직접 CPU에 프로그램을 실행하도록 할 수 있지만 과정이 매우 복잡🤮 <br>
<br><br>
**🤮운영체제 없이 직접 실행이 복잡한 이유**
- 프로그램 적재할 수 있는 적절한 크기의 메모리 영역을 찾습니다.
- CPU 레지스터를 초기화하고 함수의 진입 포인트(entry point)를 찾아 PC 레지스터를 설정합니다.

<br><br>
**🤮순수하게 수동으로 프로그램 실행하는 단점**
1. 한 번에 하나의 프로그램만 실행할 수 있다.
   - 멀티 태스킹 불가 (다중 코어 최대한 활용 불가) 
2. 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해야 하며, 그렇지 않으면 프로그램이 외부 장치를 전혀 사용할 수 없다.
   - 프로그램이 사운드 카드를 사용한다면 사운드 카드 드라이버를 연결해야 함
   - 네트워크 카드를 사용한다면 네트워크 카드 드라이버 연결 및 네트워크 통신 TCP/IP  스택 소스 코드에도 연결해야 함
3. print 함수는 직접 구현해야 함. 최신 운영 체제는 유용한 라이브러리를 다양하게 제공함.
4. 아름다운 상호 작용 인터페이스(interactive interface)를 원한다면 이 모든 것을 직접 구현해야 함

위는 사실 1950~60 년대 프로그램 작성방식. <br>

<br><br>
**🧐프로그램 실행 시 실행 파일을 메모리에 수동으로 복사를 프로그램이 대신 수행하도록 한다면?** <br>
<br>실습 <br>
적재 도구(loader)라는 이름의 프로그램을 하나 작성했고, 적재 도구를 실행하면 프로그램이 메모리에 적재됩니다. <br>
그렇다면 프로그램이 실행된 이후는 여전히 하나의 프로그램만 실행할 수 있을까? <br>
CPU가 하나뿐인 단일 코어 컴퓨터에서 웹 서핑과 코드 작성을 **✌🏻동시✌🏻**에 하고 싶다면 어떻게 해야 할까요? <br>
CPU는 한 번에 한 가지 일만 할 수 있습니다.
> CPU는 먼저 프로그램 A를 실해했다가 이를 잠시 📌중지📌하고 프로그램 B의 실행으로 넘어갑니다. <br>
> 그리고 반대로 B를 실행했다가 이를 잠시 📌중지📌하고 다시 A의 실행으로 돌아갈 수 있습니다. <br>
> **💁🏻 즉, CPU의 전환 빈도가 충분히 빠르다면 A와 B가 '동시에 실행'되는 것처럼 보입니다.**


<br><br>
**🧐포인트는 중지와 실행인데 > 어떻게 하면 프로그램을 일시 중지했다가 다시 시작하느냐가 관건** <br>
<br>농구 경기에서 일시 중지했다가 다시 재개할 떄 처럼 <br>
**일시 중지되었을 때 상태가 유지되고, 그 유지되었던 상태를 이용하여 다시 경기를 재개** <br>
**📌 이때 저장되는 상태를 상황 정보(context)라고 합니다.**

```c
struct ***
{
  context ctx; // CPU의 상황 정보 저장
  ...
}
```

> **우리는 위 구조체에 프로세스(process)라는 이름을 붙입니다.** <br>
> 이제 모든 프로그램은 실행된 후 **✌🏻프로세스 형태로 관리✌🏻** 됩니다. <br>
> 프로세스를 사용하면 모든 프로세스를 원하는 대로 일시 중지하거나 다시 시작할 수 있습니다. => 멀티태스킹 기능 구현 가능해짐

<br>
위 과정을 쭈욱 보면 프로그램을 실행할 떄마다 자동으로 적재해주는 프로그램과 <br>
프로그램을 멀티 태스킹이 가능하게 프로세스로 관리 도구처럼 멋진 기능들을 사용하기 위해 <br>
전체적으로 종합적으로 모아 둔 프로그램 => 운영체제(operating system)


<br>
<div id='id-section4'/>

### 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다

```c
int main()
{
   int resA = funcA();
   int resB = funcB();

   print(resA + resB);

   return 0;
}
```

![스크린샷, 2025-02-23 오후 1 16 55](https://github.com/user-attachments/assets/fa481139-e988-4287-8845-aca9f7fb365f)

이 프로그램이 실행 중일 때 메모리 내 해당 프로세스의 상황은 위 그림과 같습니다. <br><br>

운영 체제의 가상 메모리는 그림과 같이 <br>
각각의 프로세스가 **📌표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게** 합니다. <br>
위를 프로세스 주소 공간(process address space)라고 하겠습니다.
- **코드 영역(code segment)**: 코드를 컴파일하여 생성된 기계 명령어가 저장됩니다.
- **데이터 영역(data segment)**: 전역 변수 등이 저장됩니다.
- **힙 영역(heap segment)**: malloc 함수가 요청을 반환한 메모리가 여기에 할당됩니다.
- **스택 영역(stack segment)**: 함수의 실행 시간 스택입니다.


위 코드는 먼저 funcA 함수를 호출하여 그 결과를 얻고, <br>
funcB 함수를 호출하여 결과를 얻은 후 이 두 결과를 더합니다. <br>
두 함수를 보면 모두 독립적입니다. <br><br>

**🧐 여기서 만약 funcA 와 funcB가 각각 3,4 분씩 걸리는 함수라면? 위 방법이 최선인가?** <br>
> 우리에게는 프로세스가 있습니다. <br>
> 1. 먼저 프로세스 A와 프로세스 B를 생성하여 각각 funcA와 funcB의 결과를 얻은 후 <br>
> 2. 프로세스 B의 결과 -> 프로세스 A에 전달하여 값 두 개를 더하는 것 <br>
> 여기서 프로세스 B의 결과를 프로세스 A로 전달할 때 프로세스 사이에 통신 문제가 발생할 수 있습니다. <br>
> 위 과정이 다중 프로세스 프로그래밍(multi-process programming)과 프로세스 간 통신(inter-process communication)의 모습 <br>

다중 프로세스는 다음과 같은 단점이 있습니다.
1. 프로세스를 생성할 때 비교적 큰 부담(overhead)이 걸립니다.
2. 프로세스마다 자체적인 주소 공간을 가지고 있기 때문에 프로스세 간 통신은 프로그래밍하기에 더 복잡합니다.

🥺 그러면 더 좋은 방법은 없을까..?

<br>
<div id='id-section5'/>

### 2.1.4 프로세스에서 스레드로 진화

프로세스의 주소 공간에는 CPU가 실행하는 기계 명령어와 함수가 실행될 때 스택 정보가 저장됩니다.<br>
그리고 우리가 프로세스를 실행하려면 main 함수의 첫 번째 기계 명령어 주소를 PC 레지스터에 기록해야 합니다. <br>
이 과정을 거치면 명령어 실행 흐름이 형성  <br>

<br>
프로세스 단점은 진입 함수(entry point)가 main 함수 하나밖에 없어 프로세스의 기계 명령어를 한 번에 하나의 CPU 에서만 실행할 수 있다는 것. <br>
그렇다면 CPU 여러 개가 동일한 프로세스의 기계 명령어를 실행하게 할 방법은 없을까? <br>

<br>
앞서 언급했듯이 main 함수의 첫 번째 명령어 주소를 PC 레지스터에 기록할 수 있다는 사실 <br>

⚡️**PC 레지스터가 다른 어떤 함수라도 가리키게 할 수 있으며, 이를 통해 새로운 실행 흐름을 형성할 수 있습니다** <br>
🤩**가장 중요한 점은 이런 실행 흐름이 동일한 프로세스 주소 공간을 공유하므로, 더이상 프로세스 간 통신이 필요하지 않다는 것.**

![스크린샷, 2025-02-23 오후 1 50 52](https://github.com/user-attachments/assets/90423b05-a624-4074-9586-6ee44c06d843)


CPU 여러 개가 한 지붕 아래에 있는 것과 마찬가지로 공유 프로세스 주소 공간에서 <br>
동일한 프로세스의 속한 명령어를 동시에 실행할 수 있습니다. <br>
하나의 프로세스 안에 여러 실행 흐름이 존재 => 스레드(thread) 탄생한 배경 <br><br>

스레드로 개선한 코드
```c
int resA;
int resB;

void funcA()
{
   resA = 1;
}

void funcB()
{
   resB = 2;
}

int main()
{
   thread ta(funcA);
   thread tb(funcB);

   ta.join();
   tb.join();

   print(resA + resB);

   return 0;
}

```
앞의 경우처럼 두 함수 실행 시간이 각 3분과 4분이라고 가정하고 이상적인 상황에서 이 스레드 두 개가 CPU 코어 두 개에서 동시에 실행된다고 가정 <br>
전체 프로그램 실행 시간은 더 오래 실행되는 함수에 따라 4분이 걸립니다. <br>

📌**여기에서는 두 값을 더하는 과정에서 프로세스 간 통신이 일어나지 않았다는 점에 주목** <br>

애초에 스레드 사이에 통신이라는 개념이 존재하지 않는데 이는 resA 변수와 resB 변수가 다중 프로세스 프로그래밍 때처럼 더 이상 서로 다른 주소 공간이 아닌 <br>
**동일한 프로세스 주소 공간에 속해 있기 때문** <br>
**이것은 스레드가 자신이 속해 있는 프로세스의 주소 공간을 공유한다는 의미 -> 스레드가 프로세스보다 훨씬 가볍고 생성 속도가 빠른 이유** <br>
이런 이유로 경량 프로세스(light weight process)라고도 함. <br><br>

다중 코어가 있어야만 다중 스레드(multi-threading)을 사용할 수 있는 것은 아니며, <br>
단일 코어인 상황에서도 스레드 여러 개를 생성할 수 있습니다. <br>
이는 스레드가 운영 체제 계층에 구현되며 **코어 개수와는 무관하기 때문** <br>
**CPU가** 기계 명령어를 실행할 때도 실행 중인 기계 명령어가 **어떤 스레드에 속해 있는지 인식하지 못함.** <br>

⚡️ 스레드는 또한 GUI 프로그래밍 시 특정 이벤트(event)를 처리하는데 많은 시간이 필요하여 응답이 없는 상황을 방지하고자 해당 이벤트를 처리하는 별도의 스레드를 생성 <br><br>

**🧐스레드의 편의성은 곧 문제점이 될 수도 있음**
- 다중 스레드가 공유 리소스에 접근할 때 오류가 발생하는 것은 CPU가 명령어를 실행할 때 스레드를 전혀 고려하지 않기 때문.
  - **프로그래머는 🛠상호 배제(mutual exclusion)🛠와 🛠동기화(synchronization)🛠을 이용하여 <br>
    다중 스레드 공유 리소스 문제를 명시적으로 직접 해결**


<br>
<div id='id-section5'/>

### 2.1.5 다중 스레드와 메모리 구조

**CPU <-> 쓰레드 관련성** <br>
> **📌 즉 CPU의 PC 레지스터에 스레드의 진입 함수 주소를 지정하면 스레드를 실행시킬 수 있다는 것** <br>
> (스레드를 생성할 때 진입 함수를 반드시 지정해야 하는 이유)

<br><br>
**🧐 CPU <-> 메모리 관련성은..?** <br>

우선 함수 실행에 필요한 정보에 대해 알아봐야 한다. <br>

- 매개변수(parameter)
- 지역변수
- 반환 주소(return address) 등등

위 정보는 대응하는 스택 프레임(stack frame)에 저장되며, <br>
**모든 함수는 실행 시에 자신만의 실행 시간 스택 프레임(runtime stack frame)을 가진다.**
<br><br>
함수가 호출되고 반환될 때마다 스택 프레임은 ✌🏻후입선출(last in first out)✌🏻 순서로 증가하거나 감소 <br>
이런 스택 프레임의 증감이 **프로세스 주소 공간에서 스택 영역을 형성**
<br><br>

프로세스 내에 실행 흐름이 '👆하나' 라면 => 스택 영역도 '👆하나' <br>
프로세스 내에 실행 흐름이 '🙌🏻여러개' 라면 => 스택 영역도 '🙌🏻여러개' => **⚡️각 스레드를 위한 스택 영역이 별도** <br>
(실행 진입점(execution entry point) 여러개) <br>

![스크린샷, 2025-02-26 오후 11 24 33 2](https://github.com/user-attachments/assets/ed2bfbaa-cbcb-4da5-bbaa-480001b5865e)


<br>
<div id='id-section6'/>

### 2.1.6 스레드 활용 예

스레드가 처리해야 할 작업
- 긴 작업(long task)
  - Word 문서 편집 저장
- 짧은 작업(short task)
  - 웹 서버, 데이터베이스 서버, 파일 서버, 메일 서버 

위의 짧은 작업에는 두 가지 상황에 직면
- 작업 처리에 필요한 시간이 짧다는 것
- 작업 수가 엄청나게 많다는 것

<br>

**🧐 이런 작업을 어떻게 처리할 것인가?** <br>
하나의 요청을 받으면 해당 작업을 처리하는 스레드를 생성 -> 요청당 스레드(thread-per-request) <br>
위의 방법은 ✌🏻긴 작업✌🏻 대상으로는 매우 잘 동작하나,<br> 
짧은 작업에서는 구현이 간단하지만 몇 가지 **🔴단점**이 존재. <br>
1. 스레드의 생성과 종료에 많은 시간을 허비
2. 스레드마다 독립적인 스택 영역이 필요한데, 많은 수의 스레드를 생성하면 메모리와 기타 시스템 리소스를 너무 많이 소비하게 됩니다.
3. 스레드 수가 많으면 스레드 간 전환에 따른 부담이 증가합니다.

<br><br>
가령 공장의 사장이고, 주문이 매우 많은데 <br>
주문 하나가 새로 추가될 때마다 새로운 근로자를 고용한다고 생각해보면 <br>
제품 생산 과정이 매우 간단하고 짧기 떄문에 근로자는 주문을 빠르게 처리 가능함 <br>
주문 처리가 완료되면 고용한 근로자를 금방 해고하고, 새로운 주문이 들어오면 <br> 
어렵사리 또 다른 근로자를 고용 <br>
=> 스레드 풀(thread pool)이 탄생하게 된 이유

<br>
<div id='id-section7'/>

### 2.1.7 스레드 풀의 동작 방식

**💁🏻 정의**
> **스레드 여러 개를 미리 생성해 두고, 스래드가 처리할 작업이 생기면 해당 스레드에 처리를 요청하는 것**

<br>

스레드풀 사용 시 장점
- 생성과 종료 작업이 빈번하게 발생하지 않음
- 스레드 풀 내에 있는 스레드 수도 일반적으로 일정하게 관리 > 불필요하게 많은 메모리를 소비하지 않음
- 핵심은 스레드를 재사용하는 것

<br>

**🧐 스레드 풀 내에 있는 스레드에 전달은 어떻게?** <br>
대기열(queue)를 사용하여 (producer-consumer pattern) 전달<br>
- 작업을 전달하는 > 생산자(producer)
- 작업을 처리하는 > 소비자(consumer)

![스크린샷, 2025-03-02 오후 3 19 25](https://github.com/user-attachments/assets/aad6c806-aa26-4787-8869-34a1996f607b)

스레드 풀에 전달되는 ✌🏻**작업은**✌🏻 <br>
- 처리할 데이터와
- 데이터를 처리하는 함수
```c
struct task
{
   void* data; // 작업이 처리할 데이터
   handler handle; // 데이터 처리 함수
}
```

스레드 풀의 스레드는 <br>
작업 대기열(jobs queue)에서 블로킹 상태로 대기함<br>
생산자가 작업 대기열에 데이터를 기록하면 <br>
스레드 풀의 스레드가 깨어나고 <br>
깨어난 스레드는 작업 대기열에서 앞서 정의한 구조체를 가져온 후 <br>
구조체의 handle이 가리키는 처리 함수(handle function)를 실행

(스레드는 함수를 받아서 pc가 가리키게 하는 함수니까 task.handle을 처리하면 됨)

```c
while(true)
{
   struct task = GetFromQueue(); // 작업 대기열에서 데이터 꺼내기
   task->handle(task->data);     // 데이터 처리
}
```

여기서 작업 대기열(task queue)는 여러 스레드 간에 공유되는 리소스이므로 <br>
동기화를 할 때 상호 배제(mutual exclusion in synchronization) 문제도 반드시 처리해야 함 <br>


<br>
<div id='id-section8'/>

### 2.1.8 스레드 풀의 스레드 수

**🧐스레드 풀의 스레드 수는 몇 개여야 할까?** <br>
스레드 수가 너무 적다면 => CPU를 최대한 활용할 수 없음 <br>
스레드 수가 너무 많다면 => 시스템의 성능 저하, 메모리의 과다한 점유, 스레드 전환으로 생기는 부담 등 문제 발생 <br>
<br>

작업을 처리할 때 필요한 리소스 관점 <br>
- CPU 집약적인 작업 (CPU intensive task)
   - 과학 연산, 행렬 연산 등 작업 처리할 때 외부 입출력에 의존할 필요없이 처리할 수 있는 작업
   - 스레드 수 => CPU의 코어 수가 기본적으로 동일 CPU의 리소스를 충분히 화용
- 입출력 집약적인 작업 (input/output intensive task)
   - 대부분의 시간을 디스크 입출력이나 네트워크 입출력 등에 소비하는 작업
   - 성능 테스트 도구를 사용하여 WT(Wait Time)라는 입추력 대기 시간과 CT(Computing Time)이라는 CPU 연산에 필요한 시간을 평가해야 함
   - N개의 코어를 가진 시스템에서 적절한 스레드 수는 대략 => N * (1 + WT / CT), WT와 CT가 동일하다고 가정하면 대략 2N개의 스레드
- 실제 상황을 기반으로 테스트를 실시하여 필요한 스레드 수를 결정해야 함
