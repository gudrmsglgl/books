# 프로그래밍 언어부터 프로그램 실행까지, <br>이렇게 진행된다.

## section1 여러분이 프로그래밍 언어를 발명한다면?

프로그래밍 언어
- 컴퓨터에 명령을 내리는 도구일 뿐


<br>

### 1.1.1 창세기: CPU는 똑똑한 바보

CPU
- 데이터를 한곳에서 다른 곳으로 옮기고 간단히 연산
- 다시 그 데이터를 또 다른 자리로 옮기는 작업
<br>

천공 카드(punched card)를 이용하여 컴퓨터 작업을 제어

😰이 때는 프로그래머 CPU에 의지에 따라 직접 0과 1로 구성된 명령어 작성

<br>

### 1.1.2 어셈블리어 등장
- 기계어와 해당 특정 작업을 간단하게 대응시켜 <br>기계어를 인간이 읽고 이해할 수 있는 단어와 대응
- 프로그래머는 1101... 을 기억할 필요 없이 add, sub, mov 만 인식하면 됨
- 기계 명령어 ----> 0,1로 구성된 바이너리로 변환

(아직 우리가 일상에서 사용하는 언어 형식과는 많은 차이)

```assmbly
sub $8, %rsp
mov $.LC0, %edi
call puts
mov $0, %eax
```


<br>

### 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화
- 어셈블리어는 기계어와 마찬가지로 여전히 저수준 언어(low-level language)
- 모든 세부 사항에 대해 신경을 써야 한다는 의미
- 이는 우리가 옮기는 작업과 연산 작업을 ✌🏻일일이 ✌🏻 해줘야 한다는 뜻
  - '데이터를 한곳에서 다른 곳으로 이동시키고, 간단히 연산한 후 또다시 다른 곳으로 이동시키는 것'

<table>
 <tr>
    <td>고수준 명렁어 예시</td>
    <td>저수준 명령어 예시</td>
  </tr>
 <tr>
    <td>저에게 물 한 잔 주세요.</td>
    <td>오른쪽 다리를 내딛는다 <br>멈춘다 <br>왼쪽 다리를 내딛는다 <br>멈춘다 <br>앞의 걸음을 음수대 옆에 도착할 떄까지 반복한다 <br>물컵을 찾는다 <br>오른손을 들어올린다 <br>물컵을 잡는다 <br>수도꼭지로 이동한다 <br>왼손을 뻗는다 <br>수도꼭지를 연다 <br>물이 아직 가득 차지 않았다면 <br>계속 기다린다 <br>물이 이미 가득 찼다면 <br>수도꼭지를 잠근다 <br>뒤로 180도 돈다 <br>오른쪽 다리를 내딛는다 <br>멈춘다 <br>왼쪽 다리를 내딛는다 <br>멈춘다 <br> 앞의 걸음을 돌아올 때까지 반복한다 </td>
  </tr>
</table>

- 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환할 수 있는 방법


<br>

### 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작

<br>

> _위의 명렁어에서 규칙 또는 패턴이 존재함_
- CPU에 특정 작업을 수행하라고 단도직입적으로 말함 => 📌**명령어에 문(statement) 또는 문장**
- 특정 상황에 따라 어떤 명령어를 실행할지 결정해야 하는 선택이 필요 => 인간의 규칙 => 📌**만약 ~ 라면 ...하고, 그렇지 않으면 ---한다.**
```kotlin
if ~~~
  ccccc
else
  dddd
```
- 어떤 경우에는 일정한 명령어를 계속 반복
```kotlin
while ****
  bbbbbbb
```
- 특정 명령어는 개별적인 세부 사항만 다소 차이가 있을 뿐 계속 반복
  - 📌**이런 차이를 매개변수(parameter)**
  - 📌**매개변수를 제외한 나머지 명령어를 하나로 묶어 하나의 코드로 지정 => 함수**
```kotlin
func abc:
    abcd
```
<br>

#### 🧐 여기까지 봤을 때 의문사항
> 1. 위의 코드 (cccc, dddd, bbbbbbb, abcd) 는 무엇일까? <br>
> 2. 앞의 코드처럼 인간이 인식할 수 있는 문자열을 
> <br> 어떻게 CPU가 인식할 수 있는 기계 명령어로 변환할 수 있을까? <br> (문자열 => 기계어)


<br>

### 1.1.5 <인셉션>과 재귀: 코드 본질

위의 1번 의문 사항 대답 <br>
=> 조건에 따른 이동 if else, 순환 while, 함수 호출 모두가 될 수 있다.
> 추가 문제 사항 <br>
> --> 만약 그 안에 다시 if else , 또 그 안에 if else, 이렇게 계속 반복된다면 🤮 ..? 

![IMG_0380](https://github.com/user-attachments/assets/3058a8e5-f35f-4104-8e4a-7fe82dd8f9fd)

<br>

위를 수학식으로 이해해보면 다음과 같습니다

$$
\begin{align}
f(x) = f(x-1) + f(x-2)
\end{align}
$$


이 수열 표현식은 무엇을 의미
```text
f(x)는
- f(x-1)에 의존하고 -> f(x-1)는 -> f(x-2)와 f(x-3)에 의존하며
- f(x-2)는 -> f(x-3)과 f(x-4)에 의존
```
![IMG_0381](https://github.com/user-attachments/assets/5219d271-f49a-4667-ab50-0c9b0695f6e4)

**📌위가 바로 재귀로 표현할 수 있다는 의미**
> 세상의 모든 코드는 아무리 복잡하더라도 결과적으로 모두 '구문'으로 귀결됩니다.

<br>

### 1.1.6 컴퓨터가 재귀를 이해하도록 만들기

나무줄기를 보면 나무줄기에는 나뭇가지고 있고, 그 나뭇가지에는 잎이나 또 다른 나뭇가지가 잇을 수 있습니다. <br>

**💡 구문 트리 (syntax tree)**
> 이 부분 또한 '재귀'이며
위의 나무에서 영감을 얻어 <br>
재귀 구문에 따라 작성된 코드를 <br>
트리(tree) 구조로 표현할 수 있습니다. <br>

![IMG_0382](https://github.com/user-attachments/assets/2cedc592-7d0d-4270-83e7-e577b1bf2c78)

<br>

### 1.1.7 우수한  번역가: 컴파일러

이제 코드는 트리 형태로 표현될 수 있습니다. <br>
자세히 살펴보면 리프 노드(leap node)의 표현이 매우 간단하게 바뀌어서 <br>
매우 간단하게 기계 명령어로도 번역할 수 있다는 것을 알 수 있습니다.

**💡 컴파일러**
> 이렇게 번역 결과를 차례대로 부모 노드에 적용하는 방식으로 올라가다보면 <br>
결국 전체 트리를 구체적인 기계 명령어로 번역할 수 있습니다.

![IMG_0383](https://github.com/user-attachments/assets/89d00ffd-98cf-4043-830a-685d64fa375f)







## section2 컴파일러는 어떻게 작동하는 것일까?

## section3 
