# 프로그래밍 언어부터 프로그램 실행까지, <br>이렇게 진행된다.

목차 <br>
[Section1.1 프로그래밍 언어를 발명한다면?](#id-section1)<br>
- [1.1.1 창세기: CPU는 똑똑한 바보](#id-section2)<br>
- [1.1.2 어셈블리어 등장](#id-section3)<br>
- [1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화](#id-section4)<br>
- [1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작](#id-section5)<br>
- [1.1.5 <인셉션>과 재귀: 코드 본질](#id-section6)<br>
- [1.1.6 컴퓨터가 재귀를 이해하도록 만들기](#id-section7)<br>
- [1.1.7 우수한  번역가: 컴파일러](#id-section8)<br>
- [1.1.8 해석형 언어의 탄생](#id-section9)<br>

[Section1.2 컴파일러는 어떻게 작동하는 것일까?](#id-section10)<br>
- [1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다](#id-section11)<br>
- [1.2.2 각각의 토큰 추출하기](#id-section12)<br>
- [1.2.3 ](#id-section13)<br>
- [1.2.4 ](#id-section14)<br>


<div id='id-section1'/>
  
## section1 여러분이 프로그래밍 언어를 발명한다면?

프로그래밍 언어
- 컴퓨터에 명령을 내리는 도구일 뿐


<br>
<div id='id-section2'/>
  
### 1.1.1 창세기: CPU는 똑똑한 바보

CPU
- 데이터를 한곳에서 다른 곳으로 옮기고 간단히 연산
- 다시 그 데이터를 또 다른 자리로 옮기는 작업
<br>

천공 카드(punched card)를 이용하여 컴퓨터 작업을 제어

😰이 때는 프로그래머 CPU에 의지에 따라 직접 0과 1로 구성된 명령어 작성

<br>
<div id='id-section3'/>


### 1.1.2 어셈블리어 등장
- 기계어와 해당 특정 작업을 간단하게 대응시켜 <br>기계어를 인간이 읽고 이해할 수 있는 단어와 대응
- 프로그래머는 1101... 을 기억할 필요 없이 add, sub, mov 만 인식하면 됨
- 기계 명령어 ----> 0,1로 구성된 바이너리로 변환

(아직 우리가 일상에서 사용하는 언어 형식과는 많은 차이)

```assmbly
sub $8, %rsp
mov $.LC0, %edi
call puts
mov $0, %eax
```


<br>
<div id='id-section4'/>

### 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화
- 어셈블리어는 기계어와 마찬가지로 여전히 저수준 언어(low-level language)
- 모든 세부 사항에 대해 신경을 써야 한다는 의미
- 이는 우리가 옮기는 작업과 연산 작업을 ✌🏻일일이 ✌🏻 해줘야 한다는 뜻
  - '데이터를 한곳에서 다른 곳으로 이동시키고, 간단히 연산한 후 또다시 다른 곳으로 이동시키는 것'

<table>
 <tr>
    <td>고수준 명렁어 예시</td>
    <td>저수준 명령어 예시</td>
  </tr>
 <tr>
    <td>저에게 물 한 잔 주세요.</td>
    <td>오른쪽 다리를 내딛는다 <br>멈춘다 <br>왼쪽 다리를 내딛는다 <br>멈춘다 <br>앞의 걸음을 음수대 옆에 도착할 떄까지 반복한다 <br>물컵을 찾는다 <br>오른손을 들어올린다 <br>물컵을 잡는다 <br>수도꼭지로 이동한다 <br>왼손을 뻗는다 <br>수도꼭지를 연다 <br>물이 아직 가득 차지 않았다면 <br>계속 기다린다 <br>물이 이미 가득 찼다면 <br>수도꼭지를 잠근다 <br>뒤로 180도 돈다 <br>오른쪽 다리를 내딛는다 <br>멈춘다 <br>왼쪽 다리를 내딛는다 <br>멈춘다 <br> 앞의 걸음을 돌아올 때까지 반복한다 </td>
  </tr>
</table>

- 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환할 수 있는 방법


<br>
<div id='id-section5'/>


### 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작

<br>

> _위의 명렁어에서 규칙 또는 패턴이 존재함_
- CPU에 특정 작업을 수행하라고 단도직입적으로 말함 => 📌**명령어에 문(statement) 또는 문장**
- 특정 상황에 따라 어떤 명령어를 실행할지 결정해야 하는 선택이 필요 => 인간의 규칙 => 📌**만약 ~ 라면 ...하고, 그렇지 않으면 ---한다.**
```kotlin
if ~~~
  ccccc
else
  dddd
```
- 어떤 경우에는 일정한 명령어를 계속 반복
```kotlin
while ****
  bbbbbbb
```
- 특정 명령어는 개별적인 세부 사항만 다소 차이가 있을 뿐 계속 반복
  - 📌**이런 차이를 매개변수(parameter)**
  - 📌**매개변수를 제외한 나머지 명령어를 하나로 묶어 하나의 코드로 지정 => 함수**
```kotlin
func abc:
    abcd
```
<br>

#### 🧐 여기까지 봤을 때 의문사항
> 1. 위의 코드 (cccc, dddd, bbbbbbb, abcd) 는 무엇일까? <br>
> 2. 앞의 코드처럼 인간이 인식할 수 있는 문자열을 
> <br> 어떻게 CPU가 인식할 수 있는 기계 명령어로 변환할 수 있을까? <br> (문자열 => 기계어)


<br>
<div id='id-section6'/>


### 1.1.5 <인셉션>과 재귀: 코드 본질

위의 1번 의문 사항 대답 <br>
=> 조건에 따른 이동 if else, 순환 while, 함수 호출 모두가 될 수 있다.
> 추가 문제 사항 <br>
> --> 만약 그 안에 다시 if else , 또 그 안에 if else, 이렇게 계속 반복된다면 🤮 ..? 

![IMG_0380](https://github.com/user-attachments/assets/3058a8e5-f35f-4104-8e4a-7fe82dd8f9fd)

<br>

위를 수학식으로 이해해보면 다음과 같습니다

$$
\begin{align}
f(x) = f(x-1) + f(x-2)
\end{align}
$$


이 수열 표현식은 무엇을 의미
```text
f(x)는
- f(x-1)에 의존하고 -> f(x-1)는 -> f(x-2)와 f(x-3)에 의존하며
- f(x-2)는 -> f(x-3)과 f(x-4)에 의존
```
![IMG_0381](https://github.com/user-attachments/assets/5219d271-f49a-4667-ab50-0c9b0695f6e4)

**📌위가 바로 재귀로 표현할 수 있다는 의미**
> 세상의 모든 코드는 아무리 복잡하더라도 결과적으로 모두 '구문'으로 귀결됩니다.

<br>
<div id='id-section7'/>


### 1.1.6 컴퓨터가 재귀를 이해하도록 만들기

나무줄기를 보면 나무줄기에는 나뭇가지고 있고, 그 나뭇가지에는 잎이나 또 다른 나뭇가지가 잇을 수 있습니다. <br>

**💡 구문 트리 (syntax tree)**
> 이 부분 또한 '재귀'이며
위의 나무에서 영감을 얻어 <br>
재귀 구문에 따라 작성된 코드를 <br>
트리(tree) 구조로 표현할 수 있습니다. <br>

![IMG_0382](https://github.com/user-attachments/assets/2cedc592-7d0d-4270-83e7-e577b1bf2c78)

<br>
<div id='id-section8'/>

### 1.1.7 우수한  번역가: 컴파일러

이제 코드는 트리 형태로 표현될 수 있습니다. <br>
자세히 살펴보면 리프 노드(leap node)의 표현이 매우 간단하게 바뀌어서 <br>
매우 간단하게 기계 명령어로도 번역할 수 있다는 것을 알 수 있습니다.

**💡 컴파일러**
> 이렇게 번역 결과를 차례대로 부모 노드에 적용하는 방식으로 올라가다보면 <br>
결국 전체 트리를 구체적인 기계 명령어로 번역할 수 있습니다.

![IMG_0383](https://github.com/user-attachments/assets/89d00ffd-98cf-4043-830a-685d64fa375f)

<br>
<div id='id-section9'/>

### 1.1.8 해석형 언어의 탄생

> 🤮 다양한 CPU
형식이 다른 CPU는 가각 자신만의 고유한 언어가 있다.
![IMG_0384](https://github.com/user-attachments/assets/7596b1b5-c855-4beb-9d25-a76dce6b94fb)


#### 통합하는 방법은 없을까?
> 💡 <br>
CPU는 기계 명령어를 실행하는 존재 <br> 
=> 직접 표준 명령어 집합을 정의 <br>
=> CPU의 기계 명령어 실행 과정을 **✌🏻모방✌🏻** 하는 프로그램을 작성하여 사용

가상 머신(virtual machine) 과 인터프리터(interpreter)
![IMG_0385](https://github.com/user-attachments/assets/0e0357c8-f320-4e57-9420-b2e59d299e65)

컴파일러
- 언어 구문에 따라 코드 구문을 분석 => 구문트리로 만들고
- 이 구문트리를 기계 명령어로 번역하여 CPU로 ✌🏻직접✌🏻 넘기거나
- 자바처럼 바이트 코드(byte code)로 변환한 후 **🤖가상 머신**으로 넘겨 
- 실행

<br>

> 💁🏻 고급언어는 추상적 표현이 뛰어나지만 저수준 제어 능력이 떨어짐 <br>
따라서 운영체제 중 일 부분은 어셈블리어로 작성

<br>
<div id='id-section10'/>

## section2 컴파일러는 어떻게 작동하는 것일까?
개발자가 run 버튼을 누르면 뒤에서 컴파일러는 무엇을 묵묵히 해내는지 Let's See!

<br>
<div id='id-section11'/>

### 1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다
> 컴파일러는 고수준 언어를 저수준 언어로 **✌🏻번역✌🏻하는 프로그램** <br>
==> 크게 보면 번역기, 작게 보면 텍스트 처리 프로그램(text processor)

코드는 일반적인 텍스트 파일 형태의 파일 => 소스코드

소스코드 => 컴파일러 => 실행파일 <br>

위와 같이 생성된 실행파일이<br>
CPU가 직접 실행할 수 있는 기계 명령어.

그러면 아래 코드를 인간의 관점과 기계의 관점에서 봐보면 어떤 차이가 있을까

```c
int a = 1;
int b = 2;

while (a < b)
{
  b = b - 1;
}
```

> 인간 관점 <br>
> - a 변수에 1 할당 
> - b 변수에 2 할당
> - a < b 이면 b는 1씩 줄어듬
> - 더 이상 a < b가 성립하지 않을 때까지 앞의 문장을 반복

> CPU 관점 <br>
> - 추상적인 표현이라 직접 이해할 수 없음.
> - 이때 컴파일러가 능력을 보여줌

<br>
<div id='id-section12'/>
  
### 1.2.2 각각의 토큰 추출하기


## section3 
