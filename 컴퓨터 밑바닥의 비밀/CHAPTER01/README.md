# 프로그래밍 언어부터 프로그램 실행까지, <br>이렇게 진행된다.

목차 <br>
[Section1.1 프로그래밍 언어를 발명한다면?](#id-section1)<br>
- [1.1.1 창세기: CPU는 똑똑한 바보](#id-section2)<br>
- [1.1.2 어셈블리어 등장](#id-section3)<br>
- [1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화](#id-section4)<br>
- [1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작](#id-section5)<br>
- [1.1.5 <인셉션>과 재귀: 코드 본질](#id-section6)<br>
- [1.1.6 컴퓨터가 재귀를 이해하도록 만들기](#id-section7)<br>
- [1.1.7 우수한  번역가: 컴파일러](#id-section8)<br>
- [1.1.8 해석형 언어의 탄생](#id-section9)<br>

[Section1.2 컴파일러는 어떻게 작동하는 것일까?](#id-section10)<br>
- [1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다](#id-section11)<br>
- [1.2.2 각각의 토큰 추출하기](#id-section12)<br>
- [1.2.3 토큰이 표현하고자 하는 의미](#id-section13)<br>
- [1.2.4 생성된 구문 트리에 이상은 없을까?](#id-section14)<br>
- [1.2.5 구문 트리를 기반으로 중간 코드 생성하기](#id-section15)<br>
- [1.2.6 코드 생성](#id-section16)<br>



<div id='id-section1'/>
  
## section1 여러분이 프로그래밍 언어를 발명한다면?

프로그래밍 언어
- 컴퓨터에 명령을 내리는 도구일 뿐


<br>
<div id='id-section2'/>
  
### 1.1.1 창세기: CPU는 똑똑한 바보

CPU
- 데이터를 한곳에서 다른 곳으로 옮기고 간단히 연산
- 다시 그 데이터를 또 다른 자리로 옮기는 작업
<br>

천공 카드(punched card)를 이용하여 컴퓨터 작업을 제어

😰이 때는 프로그래머 CPU에 의지에 따라 직접 0과 1로 구성된 명령어 작성

<br>
<div id='id-section3'/>


### 1.1.2 어셈블리어 등장
- 기계어와 해당 특정 작업을 간단하게 대응시켜 <br>기계어를 인간이 읽고 이해할 수 있는 단어와 대응
- 프로그래머는 1101... 을 기억할 필요 없이 add, sub, mov 만 인식하면 됨
- 기계 명령어 ----> 0,1로 구성된 바이너리로 변환

(아직 우리가 일상에서 사용하는 언어 형식과는 많은 차이)

```assmbly
sub $8, %rsp
mov $.LC0, %edi
call puts
mov $0, %eax
```


<br>
<div id='id-section4'/>

### 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화
- 어셈블리어는 기계어와 마찬가지로 여전히 저수준 언어(low-level language)
- 모든 세부 사항에 대해 신경을 써야 한다는 의미
- 이는 우리가 옮기는 작업과 연산 작업을 ✌🏻일일이 ✌🏻 해줘야 한다는 뜻
  - '데이터를 한곳에서 다른 곳으로 이동시키고, 간단히 연산한 후 또다시 다른 곳으로 이동시키는 것'

<table>
 <tr>
    <td>고수준 명렁어 예시</td>
    <td>저수준 명령어 예시</td>
  </tr>
 <tr>
    <td>저에게 물 한 잔 주세요.</td>
    <td>오른쪽 다리를 내딛는다 <br>멈춘다 <br>왼쪽 다리를 내딛는다 <br>멈춘다 <br>앞의 걸음을 음수대 옆에 도착할 떄까지 반복한다 <br>물컵을 찾는다 <br>오른손을 들어올린다 <br>물컵을 잡는다 <br>수도꼭지로 이동한다 <br>왼손을 뻗는다 <br>수도꼭지를 연다 <br>물이 아직 가득 차지 않았다면 <br>계속 기다린다 <br>물이 이미 가득 찼다면 <br>수도꼭지를 잠근다 <br>뒤로 180도 돈다 <br>오른쪽 다리를 내딛는다 <br>멈춘다 <br>왼쪽 다리를 내딛는다 <br>멈춘다 <br> 앞의 걸음을 돌아올 때까지 반복한다 </td>
  </tr>
</table>

- 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환할 수 있는 방법


<br>
<div id='id-section5'/>


### 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작

<br>

> _위의 명렁어에서 규칙 또는 패턴이 존재함_
- CPU에 특정 작업을 수행하라고 단도직입적으로 말함 => 📌**명령어에 문(statement) 또는 문장**
- 특정 상황에 따라 어떤 명령어를 실행할지 결정해야 하는 선택이 필요 => 인간의 규칙 => 📌**만약 ~ 라면 ...하고, 그렇지 않으면 ---한다.**
```kotlin
if ~~~
  ccccc
else
  dddd
```
- 어떤 경우에는 일정한 명령어를 계속 반복
```kotlin
while ****
  bbbbbbb
```
- 특정 명령어는 개별적인 세부 사항만 다소 차이가 있을 뿐 계속 반복
  - 📌**이런 차이를 매개변수(parameter)**
  - 📌**매개변수를 제외한 나머지 명령어를 하나로 묶어 하나의 코드로 지정 => 함수**
```kotlin
func abc:
    abcd
```
<br>

#### 🧐 여기까지 봤을 때 의문사항
> 1. 위의 코드 (cccc, dddd, bbbbbbb, abcd) 는 무엇일까? <br>
> 2. 앞의 코드처럼 인간이 인식할 수 있는 문자열을 
> <br> 어떻게 CPU가 인식할 수 있는 기계 명령어로 변환할 수 있을까? <br> (문자열 => 기계어)


<br>
<div id='id-section6'/>


### 1.1.5 <인셉션>과 재귀: 코드 본질

위의 1번 의문 사항 대답 <br>
=> 조건에 따른 이동 if else, 순환 while, 함수 호출 모두가 될 수 있다.
> 추가 문제 사항 <br>
> --> 만약 그 안에 다시 if else , 또 그 안에 if else, 이렇게 계속 반복된다면 🤮 ..? 

![IMG_0380](https://github.com/user-attachments/assets/3058a8e5-f35f-4104-8e4a-7fe82dd8f9fd)

<br>

위를 수학식으로 이해해보면 다음과 같습니다

$$
\begin{align}
f(x) = f(x-1) + f(x-2)
\end{align}
$$


이 수열 표현식은 무엇을 의미
```text
f(x)는
- f(x-1)에 의존하고 -> f(x-1)는 -> f(x-2)와 f(x-3)에 의존하며
- f(x-2)는 -> f(x-3)과 f(x-4)에 의존
```
![IMG_0381](https://github.com/user-attachments/assets/5219d271-f49a-4667-ab50-0c9b0695f6e4)

**📌위가 바로 재귀로 표현할 수 있다는 의미**
> 세상의 모든 코드는 아무리 복잡하더라도 결과적으로 모두 '구문'으로 귀결됩니다.

<br>
<div id='id-section7'/>


### 1.1.6 컴퓨터가 재귀를 이해하도록 만들기

나무줄기를 보면 나무줄기에는 나뭇가지고 있고, 그 나뭇가지에는 잎이나 또 다른 나뭇가지가 잇을 수 있습니다. <br>

**💡 구문 트리 (syntax tree)**
> 이 부분 또한 '재귀'이며
위의 나무에서 영감을 얻어 <br>
재귀 구문에 따라 작성된 코드를 <br>
트리(tree) 구조로 표현할 수 있습니다. <br>

![IMG_0382](https://github.com/user-attachments/assets/2cedc592-7d0d-4270-83e7-e577b1bf2c78)

<br>
<div id='id-section8'/>

### 1.1.7 우수한  번역가: 컴파일러

이제 코드는 트리 형태로 표현될 수 있습니다. <br>
자세히 살펴보면 리프 노드(leap node)의 표현이 매우 간단하게 바뀌어서 <br>
매우 간단하게 기계 명령어로도 번역할 수 있다는 것을 알 수 있습니다.

**💡 컴파일러**
> 이렇게 번역 결과를 차례대로 부모 노드에 적용하는 방식으로 올라가다보면 <br>
결국 전체 트리를 구체적인 기계 명령어로 번역할 수 있습니다.

![IMG_0383](https://github.com/user-attachments/assets/89d00ffd-98cf-4043-830a-685d64fa375f)

<br>
<div id='id-section9'/>

### 1.1.8 해석형 언어의 탄생

> 🤮 다양한 CPU
형식이 다른 CPU는 가각 자신만의 고유한 언어가 있다.
![IMG_0384](https://github.com/user-attachments/assets/7596b1b5-c855-4beb-9d25-a76dce6b94fb)


#### 통합하는 방법은 없을까?
> 💡 <br>
CPU는 기계 명령어를 실행하는 존재 <br> 
=> 직접 표준 명령어 집합을 정의 <br>
=> CPU의 기계 명령어 실행 과정을 **✌🏻모방✌🏻** 하는 프로그램을 작성하여 사용

가상 머신(virtual machine) 과 인터프리터(interpreter)
![IMG_0385](https://github.com/user-attachments/assets/0e0357c8-f320-4e57-9420-b2e59d299e65)

컴파일러
- 언어 구문에 따라 코드 구문을 분석 => 구문트리로 만들고
- 이 구문트리를 기계 명령어로 번역하여 CPU로 ✌🏻직접✌🏻 넘기거나
- 자바처럼 바이트 코드(byte code)로 변환한 후 **🤖가상 머신**으로 넘겨 
- 실행

<br>

> 💁🏻 고급언어는 추상적 표현이 뛰어나지만 저수준 제어 능력이 떨어짐 <br>
따라서 운영체제 중 일 부분은 어셈블리어로 작성

<br>
<div id='id-section10'/>

## section2 컴파일러는 어떻게 작동하는 것일까?
개발자가 run 버튼을 누르면 뒤에서 컴파일러는 무엇을 묵묵히 해내는지 Let's See!

<br>
<div id='id-section11'/>

### 1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다
> 컴파일러는 고수준 언어를 저수준 언어로 **✌🏻번역✌🏻하는 프로그램** <br>
==> 크게 보면 번역기, 작게 보면 텍스트 처리 프로그램(text processor)

코드는 일반적인 텍스트 파일 형태의 파일 => 소스코드

소스코드 => 컴파일러 => 실행파일 <br>

위와 같이 생성된 실행파일이<br>
CPU가 직접 실행할 수 있는 기계 명령어.

그러면 아래 코드를 인간의 관점과 기계의 관점에서 봐보면 어떤 차이가 있을까

```c
int a = 1;
int b = 2;

while (a < b)
{
  b = b - 1;
}
```

> 인간 관점 <br>
> - a 변수에 1 할당 
> - b 변수에 2 할당
> - a < b 이면 b는 1씩 줄어듬
> - 더 이상 a < b가 성립하지 않을 때까지 앞의 문장을 반복

> CPU 관점 <br>
> - 추상적인 표현이라 직접 이해할 수 없음.
> - 이때 컴파일러가 능력을 보여줌

<br>
<div id='id-section12'/>
  
### 1.2.2 각각의 토큰 추출하기


컴파일러는 먼저 각 항목을 잘게 쪼갬.<br>
이때 각 항목이 가지고 있는 추가 정보를 함께 묶어서 관리
> 각 항목에 추가로 정보를 결합한 것을 전문 용어로 **✌🏻토큰(token)✌🏻**

**📌 컴파일러가 하는 첫 번째 작업**
```bash
T_keyword       int
T_Identifier    a
T_Assign        =
T_Int           1
T_Semicolon     ;
T_keyword       int
T_Identifier    b
T_Assign        =
T_Int           2
T_Semicolon     ;
T_While         while
T_LeftParen     (
T_Identifier    a
T_Less          <
T_Identifier    b
T_RightParen    )
T_OpenBrace     {
T_Identifier    b
T_Assign        =
T_Identifier    b
T_Minus         -
T_Int           1
T_Semicolon     ;
T_CloseBrace    }
```

각각의 줄은 하나의 토큰을 의미 <br>
T로 시작하는 왼쪽 열은 토큰 의미 <br>
오른쪽 열은 각각의 토큰이 가지는 값

> 소소코드에서 토큰 추출하는 과정 => 어휘 분석(lexical analysis)

<br>
<div id='id-section13'/>
  
### 1.2.3 토큰이 표현하고자 하는 의미
소스 코드가 하나의 토큰으로 바뀜 <br>

> 🧐 컴파일러가 구문 트리에 따라 토큰을 처리한다는 것은 무슨 의미?

컴파일러가 while 키워드 토큰을 찾으면 <br>
위의 토큰 테이블에서 ( 라는 것을 알고 있는 상태로 기다리게 됨 <br>
하지만 다음 토큰이 while 키워드에 필요한 토큰이 아니라면, 컴파일러는 문법 오류(syntax error)를 보고 <br>
반면에 이 과정을 무사히 넘어가면 다음 토큰이 bool 표현식이여야 한다는 것을 알고 기다림 
> 이러한 과정을 해석 (parsing) 

위의 토큰 테이블로 만든 구조를 어떻게 표현할까? ==> '트리'
![IMG_0386](https://github.com/user-attachments/assets/9bbcbe16-5cd6-498b-88fa-ba2df15c0aab)
위 그림이 구문트리이고 <br>
이 트리를 생성하는 전체 과정을 '구문 분석'


<br>
<div id='id-section14'/>
  
### 1.2.4 생성된 구문 트리에 이상은 없을까?

구문 트리가 생성되고 나면 구문 트리에 이상이 없는지 확인해야 된다.<br>
예를 들어 정수 값에 문자열을 더하면 안 되고, 비교 기호의 좌우에 있는 값 형식이 다르면 안 된다. <br>

이 단계가 지나면 컴파일 오류가 없다는 것이 증명되는데,
![IMG_0387](https://github.com/user-attachments/assets/a1dc6207-b097-4ba8-b51c-532a93444858)
이 과정을 의미 분석 (semantic analysis) 라고 함.

<br>
<div id='id-section15'/>
  
### 1.2.5 구문 트리를 기반으로 중간 코드 생성하기

의미 분석이 끝나면 컴파일러는 구문 트리를 탐색한 결과를 바탕으로 <br>
좀 더 다듬어진 형태인 중간 코드(Intermediate Representation Code, IR Code)를 생성

```bash
a = 1
b = 2
goto B
A: b = b - 1
B: if a < b goto A
```
어떤 경우에는 중간 코드에 최적화가 진행되기도 함.

<br>
<div id='id-section16'/>
  
### 1.2.6 코드 생성
이 과정이 완료되면 컴파일러는 앞의 중간 코드 -> 어셈블리어 코드로 변환
```x86
    mov1    $0x1, -0x4(%rbp) // a = 1
    mov1    $0x2, -0x8(%rbp) // b = 2
    jmp     B                // b로 점프
A:  sub1    $0x1, -0x8(%rbp) // b = b - 1
B:  mov     -0x4(%rbp), %eax
    cmp     -0x8(%rbp), %eax // a < b ?
    j1      A                // a < b 이면 A로 점프
```

마지막으로 컴파일러는 이 어셈블리어 코드 -> 기계 명령어로 변환<br>
이런 방식으로 컴파일러는 인간이 소스 코드라고 불리는 **✌🏻문자열✌🏻**을 CPU가 실행할 수 있는 **🤖기계 명령어**로 번역

여기서 끝이 아니라 우리는 실행 파일을 만드는 것이 목표! <br>
> 위에서 설명한 기계 명렁어가 된 파일을 .o(object) 대상 파일이 생성되며 <br>
소스코드 -> 대상파일(N) 개를 
병합한 실행 파일로 만들어주는 작업 --> 링크(link) <br>


## section3 
