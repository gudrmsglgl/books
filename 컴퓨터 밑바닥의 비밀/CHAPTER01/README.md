# 프로그래밍 언어부터 프로그램 실행까지, <br>이렇게 진행된다.

목차 <br>
[Section1.1 프로그래밍 언어를 발명한다면?](#id-section1)<br>
- [1.1.1 창세기: CPU는 똑똑한 바보](#id-section2)<br>
- [1.1.2 어셈블리어 등장](#id-section3)<br>
- [1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화](#id-section4)<br>
- [1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작](#id-section5)<br>
- [1.1.5 <인셉션>과 재귀: 코드 본질](#id-section6)<br>
- [1.1.6 컴퓨터가 재귀를 이해하도록 만들기](#id-section7)<br>
- [1.1.7 우수한  번역가: 컴파일러](#id-section8)<br>
- [1.1.8 해석형 언어의 탄생](#id-section9)<br>

[Section1.2 컴파일러는 어떻게 작동하는 것일까?](#id-section10)<br>
- [1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다](#id-section11)<br>
- [1.2.2 각각의 토큰 추출하기](#id-section12)<br>
- [1.2.3 토큰이 표현하고자 하는 의미](#id-section13)<br>
- [1.2.4 생성된 구문 트리에 이상은 없을까?](#id-section14)<br>
- [1.2.5 구문 트리를 기반으로 중간 코드 생성하기](#id-section15)<br>
- [1.2.6 코드 생성](#id-section16)<br>

[Section1.3 링커의 말할 수 없는 비밀](#id-section17)<br>
- [1.3.1 링커는 이렇게 일한다](#id-section18)<br>
- [1.3.2 심벌 해석: 수요와 공급](#id-section19)<br>
- [1.3.3 정적 라이브러리, 동적 라이브러리, 실행파일](#id-section20)<br>
- [1.3.4 ](#id-section21)<br>


<div id='id-section1'/>
  
## section1 여러분이 프로그래밍 언어를 발명한다면?

프로그래밍 언어
- 컴퓨터에 명령을 내리는 도구일 뿐


<br>
<div id='id-section2'/>
  
### 1.1.1 창세기: CPU는 똑똑한 바보

CPU
- 데이터를 한곳에서 다른 곳으로 옮기고 간단히 연산
- 다시 그 데이터를 또 다른 자리로 옮기는 작업
<br>

천공 카드(punched card)를 이용하여 컴퓨터 작업을 제어

😰이 때는 프로그래머 CPU에 의지에 따라 직접 0과 1로 구성된 명령어 작성

<br>
<div id='id-section3'/>


### 1.1.2 어셈블리어 등장
- 기계어와 해당 특정 작업을 간단하게 대응시켜 <br>기계어를 인간이 읽고 이해할 수 있는 단어와 대응
- 프로그래머는 1101... 을 기억할 필요 없이 add, sub, mov 만 인식하면 됨
- 기계 명령어 ----> 0,1로 구성된 바이너리로 변환

(아직 우리가 일상에서 사용하는 언어 형식과는 많은 차이)

```assmbly
sub $8, %rsp
mov $.LC0, %edi
call puts
mov $0, %eax
```


<br>
<div id='id-section4'/>

### 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화
- 어셈블리어는 기계어와 마찬가지로 여전히 저수준 언어(low-level language)
- 모든 세부 사항에 대해 신경을 써야 한다는 의미
- 이는 우리가 옮기는 작업과 연산 작업을 ✌🏻일일이 ✌🏻 해줘야 한다는 뜻
  - '데이터를 한곳에서 다른 곳으로 이동시키고, 간단히 연산한 후 또다시 다른 곳으로 이동시키는 것'

<table>
 <tr>
    <td>고수준 명렁어 예시</td>
    <td>저수준 명령어 예시</td>
  </tr>
 <tr>
    <td>저에게 물 한 잔 주세요.</td>
    <td>오른쪽 다리를 내딛는다 <br>멈춘다 <br>왼쪽 다리를 내딛는다 <br>멈춘다 <br>앞의 걸음을 음수대 옆에 도착할 떄까지 반복한다 <br>물컵을 찾는다 <br>오른손을 들어올린다 <br>물컵을 잡는다 <br>수도꼭지로 이동한다 <br>왼손을 뻗는다 <br>수도꼭지를 연다 <br>물이 아직 가득 차지 않았다면 <br>계속 기다린다 <br>물이 이미 가득 찼다면 <br>수도꼭지를 잠근다 <br>뒤로 180도 돈다 <br>오른쪽 다리를 내딛는다 <br>멈춘다 <br>왼쪽 다리를 내딛는다 <br>멈춘다 <br> 앞의 걸음을 돌아올 때까지 반복한다 </td>
  </tr>
</table>

- 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환할 수 있는 방법


<br>
<div id='id-section5'/>


### 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작

<br>

> _위의 명렁어에서 규칙 또는 패턴이 존재함_
- CPU에 특정 작업을 수행하라고 단도직입적으로 말함 => 📌**명령어에 문(statement) 또는 문장**
- 특정 상황에 따라 어떤 명령어를 실행할지 결정해야 하는 선택이 필요 => 인간의 규칙 => 📌**만약 ~ 라면 ...하고, 그렇지 않으면 ---한다.**
```kotlin
if ~~~
  ccccc
else
  dddd
```
- 어떤 경우에는 일정한 명령어를 계속 반복
```kotlin
while ****
  bbbbbbb
```
- 특정 명령어는 개별적인 세부 사항만 다소 차이가 있을 뿐 계속 반복
  - 📌**이런 차이를 매개변수(parameter)**
  - 📌**매개변수를 제외한 나머지 명령어를 하나로 묶어 하나의 코드로 지정 => 함수**
```kotlin
func abc:
    abcd
```
<br>

#### 🧐 여기까지 봤을 때 의문사항
> 1. 위의 코드 (cccc, dddd, bbbbbbb, abcd) 는 무엇일까? <br>
> 2. 앞의 코드처럼 인간이 인식할 수 있는 문자열을 
> <br> 어떻게 CPU가 인식할 수 있는 기계 명령어로 변환할 수 있을까? <br> (문자열 => 기계어)


<br>
<div id='id-section6'/>


### 1.1.5 <인셉션>과 재귀: 코드 본질

위의 1번 의문 사항 대답 <br>
=> 조건에 따른 이동 if else, 순환 while, 함수 호출 모두가 될 수 있다.
> 추가 문제 사항 <br>
> --> 만약 그 안에 다시 if else , 또 그 안에 if else, 이렇게 계속 반복된다면 🤮 ..? 

![IMG_0380](https://github.com/user-attachments/assets/3058a8e5-f35f-4104-8e4a-7fe82dd8f9fd)

<br>

위를 수학식으로 이해해보면 다음과 같습니다

$$
\begin{align}
f(x) = f(x-1) + f(x-2)
\end{align}
$$


이 수열 표현식은 무엇을 의미
```text
f(x)는
- f(x-1)에 의존하고 -> f(x-1)는 -> f(x-2)와 f(x-3)에 의존하며
- f(x-2)는 -> f(x-3)과 f(x-4)에 의존
```
![IMG_0381](https://github.com/user-attachments/assets/5219d271-f49a-4667-ab50-0c9b0695f6e4)

**📌위가 바로 재귀로 표현할 수 있다는 의미**
> 세상의 모든 코드는 아무리 복잡하더라도 결과적으로 모두 '구문'으로 귀결됩니다.

<br>
<div id='id-section7'/>


### 1.1.6 컴퓨터가 재귀를 이해하도록 만들기

나무줄기를 보면 나무줄기에는 나뭇가지고 있고, 그 나뭇가지에는 잎이나 또 다른 나뭇가지가 잇을 수 있습니다. <br>

**💡 구문 트리 (syntax tree)**
> 이 부분 또한 '재귀'이며
위의 나무에서 영감을 얻어 <br>
재귀 구문에 따라 작성된 코드를 <br>
트리(tree) 구조로 표현할 수 있습니다. <br>

![IMG_0382](https://github.com/user-attachments/assets/2cedc592-7d0d-4270-83e7-e577b1bf2c78)

<br>
<div id='id-section8'/>

### 1.1.7 우수한  번역가: 컴파일러

이제 코드는 트리 형태로 표현될 수 있습니다. <br>
자세히 살펴보면 리프 노드(leap node)의 표현이 매우 간단하게 바뀌어서 <br>
매우 간단하게 기계 명령어로도 번역할 수 있다는 것을 알 수 있습니다.

**💡 컴파일러**
> 이렇게 번역 결과를 차례대로 부모 노드에 적용하는 방식으로 올라가다보면 <br>
결국 전체 트리를 구체적인 기계 명령어로 번역할 수 있습니다.

![IMG_0383](https://github.com/user-attachments/assets/89d00ffd-98cf-4043-830a-685d64fa375f)

<br>
<div id='id-section9'/>

### 1.1.8 해석형 언어의 탄생

> 🤮 다양한 CPU
형식이 다른 CPU는 가각 자신만의 고유한 언어가 있다.
![IMG_0384](https://github.com/user-attachments/assets/7596b1b5-c855-4beb-9d25-a76dce6b94fb)


#### 통합하는 방법은 없을까?
> 💡 <br>
CPU는 기계 명령어를 실행하는 존재 <br> 
=> 직접 표준 명령어 집합을 정의 <br>
=> CPU의 기계 명령어 실행 과정을 **✌🏻모방✌🏻** 하는 프로그램을 작성하여 사용

가상 머신(virtual machine) 과 인터프리터(interpreter)
![IMG_0385](https://github.com/user-attachments/assets/0e0357c8-f320-4e57-9420-b2e59d299e65)

컴파일러
- 언어 구문에 따라 코드 구문을 분석 => 구문트리로 만들고
- 이 구문트리를 기계 명령어로 번역하여 CPU로 ✌🏻직접✌🏻 넘기거나
- 자바처럼 바이트 코드(byte code)로 변환한 후 **🤖가상 머신**으로 넘겨 
- 실행

<br>

> 💁🏻 고급언어는 추상적 표현이 뛰어나지만 저수준 제어 능력이 떨어짐 <br>
따라서 운영체제 중 일 부분은 어셈블리어로 작성

<br>
<div id='id-section10'/>

## section2 컴파일러는 어떻게 작동하는 것일까?
개발자가 run 버튼을 누르면 뒤에서 컴파일러는 무엇을 묵묵히 해내는지 Let's See!

<br>
<div id='id-section11'/>

### 1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다
> 컴파일러는 고수준 언어를 저수준 언어로 **✌🏻번역✌🏻하는 프로그램** <br>
==> 크게 보면 번역기, 작게 보면 텍스트 처리 프로그램(text processor)

코드는 일반적인 텍스트 파일 형태의 파일 => 소스코드

소스코드 => 컴파일러 => 실행파일 <br>

위와 같이 생성된 실행파일이<br>
CPU가 직접 실행할 수 있는 기계 명령어.

그러면 아래 코드를 인간의 관점과 기계의 관점에서 봐보면 어떤 차이가 있을까

```c
int a = 1;
int b = 2;

while (a < b)
{
  b = b - 1;
}
```

> 인간 관점 <br>
> - a 변수에 1 할당 
> - b 변수에 2 할당
> - a < b 이면 b는 1씩 줄어듬
> - 더 이상 a < b가 성립하지 않을 때까지 앞의 문장을 반복

> CPU 관점 <br>
> - 추상적인 표현이라 직접 이해할 수 없음.
> - 이때 컴파일러가 능력을 보여줌

<br>
<div id='id-section12'/>
  
### 1.2.2 각각의 토큰 추출하기


컴파일러는 먼저 각 항목을 잘게 쪼갬.<br>
이때 각 항목이 가지고 있는 추가 정보를 함께 묶어서 관리
> 각 항목에 추가로 정보를 결합한 것을 전문 용어로 **✌🏻토큰(token)✌🏻**

**📌 컴파일러가 하는 첫 번째 작업**
```bash
T_keyword       int
T_Identifier    a
T_Assign        =
T_Int           1
T_Semicolon     ;
T_keyword       int
T_Identifier    b
T_Assign        =
T_Int           2
T_Semicolon     ;
T_While         while
T_LeftParen     (
T_Identifier    a
T_Less          <
T_Identifier    b
T_RightParen    )
T_OpenBrace     {
T_Identifier    b
T_Assign        =
T_Identifier    b
T_Minus         -
T_Int           1
T_Semicolon     ;
T_CloseBrace    }
```

각각의 줄은 하나의 토큰을 의미 <br>
T로 시작하는 왼쪽 열은 토큰 의미 <br>
오른쪽 열은 각각의 토큰이 가지는 값

> 소소코드에서 토큰 추출하는 과정 => 어휘 분석(lexical analysis)

<br>
<div id='id-section13'/>
  
### 1.2.3 토큰이 표현하고자 하는 의미
소스 코드가 하나의 토큰으로 바뀜 <br>

> 🧐 컴파일러가 구문 트리에 따라 토큰을 처리한다는 것은 무슨 의미?

컴파일러가 while 키워드 토큰을 찾으면 <br>
위의 토큰 테이블에서 ( 라는 것을 알고 있는 상태로 기다리게 됨 <br>
하지만 다음 토큰이 while 키워드에 필요한 토큰이 아니라면, 컴파일러는 문법 오류(syntax error)를 보고 <br>
반면에 이 과정을 무사히 넘어가면 다음 토큰이 bool 표현식이여야 한다는 것을 알고 기다림 
> 이러한 과정을 해석 (parsing) 

위의 토큰 테이블로 만든 구조를 어떻게 표현할까? ==> '트리'
![IMG_0386](https://github.com/user-attachments/assets/9bbcbe16-5cd6-498b-88fa-ba2df15c0aab)
위 그림이 구문트리이고 <br>
이 트리를 생성하는 전체 과정을 '구문 분석'


<br>
<div id='id-section14'/>
  
### 1.2.4 생성된 구문 트리에 이상은 없을까?

구문 트리가 생성되고 나면 구문 트리에 이상이 없는지 확인해야 된다.<br>
예를 들어 정수 값에 문자열을 더하면 안 되고, 비교 기호의 좌우에 있는 값 형식이 다르면 안 된다. <br>

이 단계가 지나면 컴파일 오류가 없다는 것이 증명되는데,
![IMG_0387](https://github.com/user-attachments/assets/a1dc6207-b097-4ba8-b51c-532a93444858)
이 과정을 의미 분석 (semantic analysis) 라고 함.

<br>
<div id='id-section15'/>
  
### 1.2.5 구문 트리를 기반으로 중간 코드 생성하기

의미 분석이 끝나면 컴파일러는 구문 트리를 탐색한 결과를 바탕으로 <br>
좀 더 다듬어진 형태인 중간 코드(Intermediate Representation Code, IR Code)를 생성

```bash
a = 1
b = 2
goto B
A: b = b - 1
B: if a < b goto A
```
어떤 경우에는 중간 코드에 최적화가 진행되기도 함.

<br>
<div id='id-section16'/>
  
### 1.2.6 코드 생성
이 과정이 완료되면 컴파일러는 앞의 중간 코드 -> 어셈블리어 코드로 변환
```x86
    mov1    $0x1, -0x4(%rbp) // a = 1
    mov1    $0x2, -0x8(%rbp) // b = 2
    jmp     B                // b로 점프
A:  sub1    $0x1, -0x8(%rbp) // b = b - 1
B:  mov     -0x4(%rbp), %eax
    cmp     -0x8(%rbp), %eax // a < b ?
    j1      A                // a < b 이면 A로 점프
```

마지막으로 컴파일러는 이 어셈블리어 코드 -> 기계 명령어로 변환<br>
이런 방식으로 컴파일러는 인간이 소스 코드라고 불리는 **✌🏻문자열✌🏻**을 CPU가 실행할 수 있는 **🤖기계 명령어**로 번역

여기서 끝이 아니라 우리는 실행 파일을 만드는 것이 목표! <br>
> 위에서 설명한 기계 명렁어가 된 파일을 .o(object) 대상 파일이 생성되며 <br>
소스코드 -> 대상파일(N) 개를 
병합한 실행 파일로 만들어주는 작업 --> 링크(link) <br>


<br>
<div id='id-section17'/>

## section3 링커의 말할 수 없는 비밀

외부 코드는 정적 라이브러리(static library) 또는 동적 라이브러리(dynamic library)형태로 제공되는데, <br>
*🧐 어떻게 자신의 프로젝트에 코드를 가져와 사용할 수 있을까?*


<br>
<div id='id-section18'/>

### 1.3.1 링커는 이렇게 일한다

**링커**는 컴파일러와 마찬가지로 **✌🏻프로그램✌🏻**에 불과 <br>
> 컴파일러가 생성한 대상 파일(.object) 여러 개를 하나로 묶어 하나의 최종 실행 파일을 생성
ex) 윈도우 EXE, 리눅스 ELF

**📌 링크가 하는 일 (SOR)**
> 1. 종속성이 올바르게 설정되어 있는지, 구현이 종속된 모듈에서 사용 가능한지 확인 <br>
참조하고 있는 외부 심벌(external symbol)에 대한 실제 구현이 어느 모듈이든지 단 하나만 있어야 하는 것 체크. <br>
링커는 이를 찾아내 연결하는 작업을 하는데, 이 과정을 심벌 해석(Symbol resolution)<br>
> 2. 링크 과정을 마친 후 최종적으로 생성된 실행 파일 생성(Object File Linking)
> 3. 인용 시 우선 임의로 설정하고 링킹 과정이 완료 후 코드를 전부 참고하여 인용된 부분을 명확하게 표시 -> 이를 재배치(Relocation)

재배치의 예) <br>
특정한 소스 파일에서 다른 모듈에 정의되어 있는 print() 함수를 참조할 때, <br>
컴파일러가 이 소스 파일을 컴파일하는 시점에는 함수가 어느 메모리 주소(memory address) 에 위치할지 정확히 알 수 없음. <br>
따라서 컴파일러는 이 함수를 N으로 표시하고 넘어감. <br>
_**이후 링크 과정에서 링커가 이런 표시들을 확인하고 한데 모아 실행 파일을 생성하는 과정에서 함수의 정확한 주소를 확인하고, <br>
N의 실제 메모리 주소로 대체한다.**_
```bash
1장                                    재배치->       1장
...                                                 ...
CPU에 대한 자세한 설명은 N쪽을 참고하세요.                   CPU에 대한 자세한 설명은 100쪽을 참고하세요.

2장                                                  2장
...                                                 ...
CPU에 대한 자세한 설명은 N쪽을 참고하세요.                   CPU에 대한 자세한 설명은 100쪽을 참고하세요.
```

<br>
<div id='id-section19'/>

### 1.3.2 심벌 해석: 수요와 공급

**📌심벌이란?**
- 전역 변수(global variable)와 함수(function)의 이름을 포함하는 모든 변수의 이름을 의미
- 지역 변수(local variable)는 모듈 내에서만 사용하여 외부 모듈에서 참조할 수 없기 때문에 링커의 관심 대상이 아님

이 단계에서 링커가 할 일.
- 대상 파일에서 참조하고 있는 각각의 모든 외부 심벌마다 대상 정의가 반드시 존재하는지
- 단 하나만 존재하는지

```c
int g_a = 1;               // 전역 변수
extern int g_e;            // 외부 변수
int func_a(int x, int y)   // 함수 참조

// 함수 구현
int func_b()
{
    int m = g_a + 2;
    return func_a(m+g_e);  
}
```

- 지역변수: func_b 함수 내에 있는 m -> 링커 관심 없음
- 전역변수: g_a, func_b 두 개가 정의. 이 심벌 두 개는 다른 모듈에서 참조할 수 있다. (g_e, func_a 변수 두 개를 참조)

  
여기서 링커는 전역변수에 관심을 갖고 있음 -> 링커가 알아야 할 두 가지 정보<br>
1. 다른 모듈에서 참조할 수 있는 심벌 두 개
2. 다른 모듈에서 정의한 심벌 두 개를 참조

<br>

**---------> 🧐 이 정보를 링커가 어떻게 알 수 있을까? ==> 🙋🏻‍♂️컴파일러**

컴파일러가 기계어를 대상파일(.object)에 저장하는데 <br>
**이 때, 실행시킬 명렁어 데이터도 포함시킴** <br>

- 명령어 부분(코드 영역): 소스 파일에 정의된 함수에서 변환된 **기계 명령어가 저장되는 부분**
- 데이터 부분(데이터 영역): 소스 파일에 전역 변수가 저장되는 부분.

![IMG_0388](https://github.com/user-attachments/assets/b2a43648-fc3d-4520-a817-9019c9d2c67c)

<br>

> 여기서 컴파일러가 링커에게 작업을 떠넘기지만 위에 **필요한 정보**를 제공해줌 <br>
이때 컴파일러가 **필요한 외부 심볼 정보를 기록하는 표를 📌심볼 테이블**이라고 함.

심볼 테이블은 공급과 수요라는 두 가지 내용만 표현
- 내가 정의한 심벌, 즉 다른 모듈에서 사용할 수 있는 심벌
- 내가 사용하는 외부 심벌

![IMG_0389](https://github.com/user-attachments/assets/21e1c790-2f65-4843-920d-ad6884b138be)


대상 파일은 링커가 작업 과정에서 필수적으로 사용하는 파일 <br>
링커는 공급이 수요를 충족하는지 확인해야 하며, <br>
각 대상 파일에서 사용할 외부 심벌이 심벌 테이블에서 <br>
유일한 정의(unique definition)을 발견하고 가능한지 확인하는 작업

> 이 떄, 참조를 찾지 못 한다면 undefined reference to 오류 발생 -> 링커가 정의를 찾지 못했을 때 불평하는 것

**💡 한줄 요약 <br>
링커가 대상파일들에서 심볼 테이블의 수요와 공급의 법칙을 충족하는지 확인하는 것 => Symbol Resolution**


<br>
<div id='id-section20'/>

### 1.3.3 정적 라이브러리, 동적 라이브러리, 실행파일

**📌 정적 라이브러리(static library)**
<br>
>
> 정의:<br>코드를 별도로 컴파일한 후 패키지로 묶고, <br>
구현된 모든 함수의 선언을 포함하는 ✌🏻헤더 파일(header file)✌🏻을 제공 <br><br>
기억할 점:<br> ✌🏻소스 파일마다✌🏻 단독으로 컴파일 한다는 것 <br><br>
확장자:<br> 윈도: .lib, 리눅스 확장자: .a

![IMG_0390](https://github.com/user-attachments/assets/7916588d-7cbf-4bae-be7b-5fd514a49c3c)


**📌 정적 링크(static linking)**
> 실행 파일을 생성할 때는 자신의 코드만 컴파일하며, 미리 컴파일이 완료된 정적 라이브러리는 <br>
다시 컴파일할 필요 없이 링크 과정에서 **✌🏻그대로 실행 파일에 복제✌🏻** <br>
외부 코드를 매번 컴파일하지 않아도 되기 때문에 컴파일 속도가 빠름
![IMG_0391](https://github.com/user-attachments/assets/a366ca19-8516-4183-824d-32bc3289654a)

<br>
정적링크는 대상 파일을 한데 모아 각가의 대상 파일에서<br>
데이터 영역과 코드 영역을 각각 결합하는 것으로 간단히 이해할 수 있음

![IMG_0392](https://github.com/user-attachments/assets/e64953b5-636f-4bcc-9338-7b7a43ec27f2)

**💡 위 구조에서 알 수 있는 점**
> - 실행 파일에도 코드 영역과 데이터 영역이 있음 <br>
>- 대상 파일과 매우 유사해 보인다<br>
>- 단, 여기서 특수한 심벌인 _start가 있으며 CPU는 이 심벌 주소에서 프로그램을 실행하는 데 필요한 기계 명령어를 찾는다. <br>
>- 위 기계 명령어를 실행한 후에 -> 우리가 작성한 main 함수를 실행하기 시작.
<br>

**🥲 정적링크 단점**
> 단점1: <br>
실행 파일 500개, 1GB 크기의 데이터가 중복된 데이터로 구성됨<br>
단점2: <br>
정적 라이브러리 코드가 변경될 때마다 정적 라이브러리에 종속된 프로그램 역시 매번 다시 컴파일해야 함

-------------------> 위 단점을 해결하는 방법은? **🙋🏻‍♂️동적 라이브러리(dynamic library)**
<br><br>

**📌 동적 라이브러리는(dynamic library)**
<br>
>
> 정의:<br>공유 라이브러리(shared library) 또는 동적 링크 라이브러리(dynamic linked library) 라고 함. <br>
데이터영역과 코드 영역 등이 포함되어 있음<br><br>
기억할 점:<br> 정적 라이브러리와 달리 모두 복사가 아닌 참조된 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행 파일에 포함 => 크기를 줄일 수 있음 <br><br>
확장자:<br> 윈도: .DLL, 리눅스 확장자: .so, 접두사로 lib를 사용 ex) libMath.so 

```bash
$ gcc -shared -fPIC -o libfoo.so a.c b.c
```

<hr>

### 실행 파일에서 정적 라이브러리와 동적 라이브러리 차이

**📌정적 라이브러리**

정작 라이브러리는 컴파일 단계에서 '실행 파일'에 함계 복사되기 떄문에 <br>
실행 파일에는 정적 라이브러리의 전체 내용이 포함.

![IMG_0393](https://github.com/user-attachments/assets/6967015b-30f7-4c40-9402-adec5479f354)
<br>


**📌동적 라이브러리**

동적 라이브러리에 의존하는 실행 파일에는 컴파일 단계에서 필수 정보만 저장되기 때문에 <br>
**동적 링크는 실제 프로그램의 실행 시점까지 미룸**

**📌동적 링크 두 가지 방식** <br><br>
**✅ 첫 번째 방식:**
- 프로그램이 메모리에 적재(디스크에서 메모리 특정 영역으로 이동)될 때 동적 링크가 진행
- **적재 도구**는 적재 과정에서 적재 도구(loader)라는 전용 프로세스가 실행되며 실행 파일이 동적 라이브러리에 ✌🏻의존 여부를 확인할✌🏻 수 있다.
- 동적 라이브러리가 필요하다면 **동적 링커(dynamic linker)라는 별도의 프로세스**가 실행되어 참조하는 동적 라이브러리 존재 여부와 위치, 심벌의 메모리 위치 등을 확인하여 링크 과정 마무리
- 위 과정이 마무리되면 프로그램이 시작, 만약 문제가 생기면 실행이 종료


![IMG_0395](https://github.com/user-attachments/assets/8eac09ba-b588-48b6-b891-12e6c5322abe)



